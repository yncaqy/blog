<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YNCAQY</title>
  
  <subtitle>ync</subtitle>
  <link href="http://localhost:4000/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2023-11-14T14:22:03.450Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>yncaqy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>123.md</title>
    <link href="http://localhost:4000/2023/11/14/123/"/>
    <id>http://localhost:4000/2023/11/14/123/</id>
    <published>2023-11-14T03:30:11.000Z</published>
    <updated>2023-11-14T14:22:03.450Z</updated>
    
    <content type="html"><![CDATA[<div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>ync</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>YNC</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>AQY</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note icon-padding simple&quot;&gt;&lt;i class=&quot;note-icon fab fa-cc-visa&quot;&gt;&lt;/i&gt;&lt;p&gt;ync&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note blue icon-padding simple&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="python" scheme="http://localhost:4000/categories/python/"/>
    
    
    <category term="123" scheme="http://localhost:4000/tags/123/"/>
    
  </entry>
  
  <entry>
    <title>print函数进阶</title>
    <link href="http://localhost:4000/2023/04/17/print%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <id>http://localhost:4000/2023/04/17/print%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</id>
    <published>2023-04-17T08:26:08.000Z</published>
    <updated>2023-11-14T12:58:39.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码部分-表示注释，就是给人看的，机器执行程序会忽略前面带-号的"><a href="#代码部分-表示注释，就是给人看的，机器执行程序会忽略前面带-号的" class="headerlink" title="代码部分#表示注释，就是给人看的，机器执行程序会忽略前面带#号的"></a><font color=blue>代码部分#表示注释，就是给人看的，机器执行程序会忽略前面带#号的</font></h3><h2 id="print输出带颜色的内容"><a href="#print输出带颜色的内容" class="headerlink" title="print输出带颜色的内容"></a>print输出带颜色的内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 格式：</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[显示方式;前景颜色;背景颜色m要打印输出内容\033[0m&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="显示方式：闪烁效果也就是5可能效果出不来"><a href="#显示方式：闪烁效果也就是5可能效果出不来" class="headerlink" title="显示方式：闪烁效果也就是5可能效果出不来"></a>显示方式：闪烁效果也就是5可能效果出不来</h2><p><img src="/img/print/show.png" alt="显示方式"></p><h2 id="前景颜色和背景颜色-可以理解成字体颜色和背景颜色"><a href="#前景颜色和背景颜色-可以理解成字体颜色和背景颜色" class="headerlink" title="前景颜色和背景颜色(可以理解成字体颜色和背景颜色)"></a>前景颜色和背景颜色(可以理解成字体颜色和背景颜色)</h2><p><img src="/img/print/front.png" alt="前景颜色和背景颜色"></p><h3 id="没有设置的话就是默认"><a href="#没有设置的话就是默认" class="headerlink" title="没有设置的话就是默认"></a>没有设置的话就是默认</h3><h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># print(&quot;\033[显示方式;前景颜色;背景颜色m要打印输出内容\033[0m&quot;)</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;31;40m月念尘\033[0m&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;32;40m月念尘\033[0m&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;33;40m月念尘\033[0m&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;34;40m月念尘\033[0m&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;35;40m月念尘\033[0m&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;36;40m月念尘\033[0m&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\033[0;37;40m月念尘\033[0m&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/print/kaitou.png" alt="开头"><br><img src="/img/print/one_to_one.png" alt="以此类推一一对应即可"></p><font color=red>!!记得开头结尾，其他颜色和显示方式对着表的数字填就好   开头："\033[" 结尾:"\033[0m"</font><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><p>··1.%d代表数字占位符，代表int整型,只能传递十进制整数（十进制就是我们正常见到的数字）</p><h4 id="代码：把代码复制到一个新文件运行一下就能看到效果"><a href="#代码：把代码复制到一个新文件运行一下就能看到效果" class="headerlink" title="代码：把代码复制到一个新文件运行一下就能看到效果"></a>代码：把代码复制到一个新文件运行一下就能看到效果</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">out = <span class="hljs-number">123</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%d&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%2d&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%3d&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%4d&quot;</span> % out)  <span class="hljs-comment"># 打印值4位，如果值大于四位就原样输出，小于就会用空格补全到四位</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%.4d&quot;</span> % out) <span class="hljs-comment"># 打印值4位，如果值大于四位就原样输出，小于就会用0补全到四位</span><br></code></pre></td></tr></table></figure><p><img src="/img/print/p.png" alt="如图"></p><p>··2.%s代表字符串占位符 ， 代表string 字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">out = <span class="hljs-string">&quot;123&quot;</span>  <span class="hljs-comment"># 记住，这不是数字，这是字符串</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%s&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%2s&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%3s&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%4s&quot;</span> % out)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%.2s&quot;</span> % out)  <span class="hljs-comment"># 和上面1的区别就是这里是截取前两个，大于它的位数也是原样输出，但是小于是截取，不是补全，复制代码运行就知道了</span><br></code></pre></td></tr></table></figure></p><h4 id="要实现字符串的拼接，使用占位符是的一种高效、常用的方式。-举个例子，下面是不使用占位符的一种写法，直接使用加号拼接字符串"><a href="#要实现字符串的拼接，使用占位符是的一种高效、常用的方式。-举个例子，下面是不使用占位符的一种写法，直接使用加号拼接字符串" class="headerlink" title="要实现字符串的拼接，使用占位符是的一种高效、常用的方式。 举个例子，下面是不使用占位符的一种写法，直接使用加号拼接字符串"></a>要实现字符串的拼接，使用占位符是的一种高效、常用的方式。 举个例子，下面是不使用占位符的一种写法，直接使用加号拼接字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Li hua&quot;</span><br>age = <span class="hljs-number">24</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello &quot;</span>+ name +<span class="hljs-string">&quot;, you are &quot;</span> + <span class="hljs-built_in">str</span>(age) + <span class="hljs-string">&quot; years old&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="换成使用占位符的，可以写为"><a href="#换成使用占位符的，可以写为" class="headerlink" title="换成使用占位符的，可以写为"></a>换成使用占位符的，可以写为</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Li hua&quot;</span><br>age = <span class="hljs-number">24</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello %s, you are %d years old&quot;</span> % (name, age))<br></code></pre></td></tr></table></figure><h4 id="既然上代码了，这里就讲一讲变量，下面帮你详细剖析这段代码"><a href="#既然上代码了，这里就讲一讲变量，下面帮你详细剖析这段代码" class="headerlink" title="既然上代码了，这里就讲一讲变量，下面帮你详细剖析这段代码"></a>既然上代码了，这里就讲一讲变量，下面帮你详细剖析这段代码</h4><p><img src="/img/print/code2.png" alt="代码解释"><br>··3.%f 代表浮点，默认保留6位小数位，而第7位根据四舍五入取值</p><h5 id="首先，明确一点，浮点数就是我们常说的小数，当作小数理解就好"><a href="#首先，明确一点，浮点数就是我们常说的小数，当作小数理解就好" class="headerlink" title="首先，明确一点，浮点数就是我们常说的小数，当作小数理解就好"></a>首先，明确一点，浮点数就是我们常说的小数，当作小数理解就好</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">f1 = <span class="hljs-number">1.23</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%f&quot;</span> % f1) <span class="hljs-comment"># 默认情况保留6位小数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%.1f&quot;</span> % f1)  <span class="hljs-comment"># 保留1位小数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%.3f&quot;</span> % f1)  <span class="hljs-comment"># 保留3位小数，没有用0补</span><br></code></pre></td></tr></table></figure><p><img src="/img/print/out.png" alt="看控制台输出"><br>··4.%r 万能统配符 （可以将后面给的参数原样打印出来，带有类型信息）</p><h5 id="直接看效果，前面也一样，不懂就复制代码运行一遍看效果"><a href="#直接看效果，前面也一样，不懂就复制代码运行一遍看效果" class="headerlink" title="直接看效果，前面也一样，不懂就复制代码运行一遍看效果"></a>直接看效果，前面也一样，不懂就复制代码运行一遍看效果</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&quot;月念尘&quot;</span><br>c = <span class="hljs-string">&quot;   月念尘&quot;</span><br>b = <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%r&quot;</span> % a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%r&quot;</span> % b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输出=%r&quot;</span> % c)<br></code></pre></td></tr></table></figure><p><img src="/img/print/out2.png" alt="看控制台输出"></p><h1 id="！！！不用死记，运行一下就知道结果了"><a href="#！！！不用死记，运行一下就知道结果了" class="headerlink" title="！！！不用死记，运行一下就知道结果了"></a><font color=red>！！！不用死记，运行一下就知道结果了</font></h1><h2 id="python的format格式化（不用记，多用就会了）"><a href="#python的format格式化（不用记，多用就会了）" class="headerlink" title="python的format格式化（不用记，多用就会了）"></a>python的format格式化（不用记，多用就会了）</h2><h3 id="直接看代码，太多文字反而解释不清，运行看效果自然懂了"><a href="#直接看代码，太多文字反而解释不清，运行看效果自然懂了" class="headerlink" title="直接看代码，太多文字反而解释不清，运行看效果自然懂了"></a>直接看代码，太多文字反而解释不清，运行看效果自然懂了</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-comment"># 这是最简单2种用法，复杂还没遇到再说</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="hljs-built_in">format</span>(name=<span class="hljs-string">&quot;菜鸟教程&quot;</span>, url=<span class="hljs-string">&quot;www.runoob.com&quot;</span>)) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网站名：&#123;0&#125;, 地址 &#123;1&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;菜鸟教程&quot;</span>, <span class="hljs-string">&quot;www.runoob.com&quot;</span>)) <span class="hljs-comment"># 0表示第一个， 1表示第二个</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0:.2f&#125; &#123;1:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.1415926</span>, <span class="hljs-number">23443</span>))<br></code></pre></td></tr></table></figure><p><img src="/img/print/out3.png" alt="看效果"></p><h1 id="大概就这些了"><a href="#大概就这些了" class="headerlink" title="大概就这些了"></a>大概就这些了</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;代码部分-表示注释，就是给人看的，机器执行程序会忽略前面带-号的&quot;&gt;&lt;a href=&quot;#代码部分-表示注释，就是给人看的，机器执行程序会忽略前面带-号的&quot; class=&quot;headerlink&quot; title=&quot;代码部分#表示注释，就是给人看的，机器执行程序会忽略前面</summary>
      
    
    
    
    <category term="python" scheme="http://localhost:4000/categories/python/"/>
    
    
    <category term="print函数进阶" scheme="http://localhost:4000/tags/print%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    
    <category term="4月17号" scheme="http://localhost:4000/tags/4%E6%9C%8817%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>输出函数print</title>
    <link href="http://localhost:4000/2023/04/17/%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0print/"/>
    <id>http://localhost:4000/2023/04/17/%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0print/</id>
    <published>2023-04-17T03:30:11.000Z</published>
    <updated>2023-11-14T13:01:28.992Z</updated>
    
    <content type="html"><![CDATA[<div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了….</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><h2 id="vscode安装完成了，接下来配置一下python的运行环境"><a href="#vscode安装完成了，接下来配置一下python的运行环境" class="headerlink" title="vscode安装完成了，接下来配置一下python的运行环境"></a>vscode安装完成了，接下来配置一下python的运行环境</h2><p><img src="/img/print/下载插件.png" alt="下载插件"></p><h3 id="插件下载完成之后就把vscode关掉重新打开"><a href="#插件下载完成之后就把vscode关掉重新打开" class="headerlink" title="插件下载完成之后就把vscode关掉重新打开"></a>插件下载完成之后就把vscode关掉重新打开</h3><h2 id="接着在桌面新建一个文件夹来存放代码文件，新建完在vscode里面打开这个文件夹"><a href="#接着在桌面新建一个文件夹来存放代码文件，新建完在vscode里面打开这个文件夹" class="headerlink" title="接着在桌面新建一个文件夹来存放代码文件，新建完在vscode里面打开这个文件夹"></a>接着在桌面新建一个文件夹来存放代码文件，新建完在vscode里面打开这个文件夹</h2><p><img src="/img/print/new.png" alt="打开新建的文件夹"></p><h2 id="打开完成之后，开始在vscode里面新建文件，写代码"><a href="#打开完成之后，开始在vscode里面新建文件，写代码" class="headerlink" title="打开完成之后，开始在vscode里面新建文件，写代码"></a>打开完成之后，开始在vscode里面新建文件，写代码</h2><p><img src="/img/print/newpy.png" alt="新建一个文件，后缀是.py"><br><img src="/img/print/py.png" alt="记得后缀是.py"></p><h2 id="接着就是在右边区域写代码，注意写完代码要CTRL-S保存一下"><a href="#接着就是在右边区域写代码，注意写完代码要CTRL-S保存一下" class="headerlink" title="接着就是在右边区域写代码，注意写完代码要CTRL+S保存一下"></a>接着就是在右边区域写代码，注意写完代码要CTRL+S保存一下</h2><p><img src="/img/print/code1.png" alt="写代码"><br><img src="/img/print/wrong.png" alt="这是一个错误的写法"></p><h3 id="记得CTRL-S保存"><a href="#记得CTRL-S保存" class="headerlink" title="记得CTRL+S保存"></a>记得CTRL+S保存</h3><p><img src="/img/print/save.png" alt="记得保存"></p><h2 id="接着运行代码"><a href="#接着运行代码" class="headerlink" title="接着运行代码"></a>接着运行代码</h2><p><img src="/img/print/run.png" alt="运行代码"></p><h2 id="运行成功"><a href="#运行成功" class="headerlink" title="运行成功"></a>运行成功</h2><p><img src="/img/print/success.png" alt="运行成功"></p><h2 id="记住一点：所有函数符号都应该是英文，除非是作为输出内容。"><a href="#记住一点：所有函数符号都应该是英文，除非是作为输出内容。" class="headerlink" title="记住一点：所有函数符号都应该是英文，除非是作为输出内容。"></a><font color=red>记住一点：所有函数符号都应该是英文，除非是作为输出内容。</font></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note icon-padding simple&quot;&gt;&lt;i class=&quot;note-icon fab fa-cc-visa&quot;&gt;&lt;/i&gt;&lt;p&gt;你是刷 Visa 还是 UnionPay&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note blue icon-</summary>
      
    
    
    
    <category term="python" scheme="http://localhost:4000/categories/python/"/>
    
    
    <category term="输出函数print" scheme="http://localhost:4000/tags/%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0print/"/>
    
    <category term="4月17日" scheme="http://localhost:4000/tags/4%E6%9C%8817%E6%97%A5/"/>
    
  </entry>
  
  <entry>
    <title>python安装</title>
    <link href="http://localhost:4000/2023/04/15/python%E5%AE%89%E8%A3%85/"/>
    <id>http://localhost:4000/2023/04/15/python%E5%AE%89%E8%A3%85/</id>
    <published>2023-04-15T08:16:10.000Z</published>
    <updated>2023-11-14T12:58:01.174Z</updated>
    
    <content type="html"><![CDATA[<h1 id="First-下载python"><a href="#First-下载python" class="headerlink" title="First:下载python"></a>First:下载python</h1><h2 id="·-打开浏览器，输入网址："><a href="#·-打开浏览器，输入网址：" class="headerlink" title="· 打开浏览器，输入网址："></a>· 打开浏览器，输入网址：</h2><pre><code>https://www.python.org/</code></pre><h2 id="·-得到一个页面："><a href="#·-得到一个页面：" class="headerlink" title="· 得到一个页面："></a>· 得到一个页面：<img src="/img/python_install/python官网.png" alt="python官网"></h2><h2 id="·-接着："><a href="#·-接着：" class="headerlink" title="· 接着："></a>· 接着：<img src="/img/python_install/找到对应平台.png" alt="找到对应平台下载"></h2><h2 id="·-下一步："><a href="#·-下一步：" class="headerlink" title="· 下一步： "></a>· 下一步： <img src="/img/python_install/找到3.8.10版本.png" alt="找到3.8.10版本"></h2><h2 id="·-下一步"><a href="#·-下一步" class="headerlink" title="· 下一步: "></a>· 下一步: <img src="/img/python_install/下载.png" alt="下载3.8.10版本python"></h2><h2 id="·-等待下载完成-gt"><a href="#·-等待下载完成-gt" class="headerlink" title="· 等待下载完成&gt;"></a>· 等待下载完成&gt;<img src="/img/python_install/waiting.jpg" alt="waiting..."></h2><h2 id="·-找到下载完成的文件双击它："><a href="#·-找到下载完成的文件双击它：" class="headerlink" title="· 找到下载完成的文件双击它："></a>· 找到下载完成的文件<em>双击它</em>：<img src="/img/python_install/下载完成.png" alt="找到下载完成的exe文件*双击它*"></h2><h3 id="我用的是3-11做安装演示，大体上一样。"><a href="#我用的是3-11做安装演示，大体上一样。" class="headerlink" title="!!我用的是3.11做安装演示，大体上一样。"></a>!!我用的是3.11做安装演示，大体上一样。</h3><h2 id="·-安装：勾选完再点击2"><a href="#·-安装：勾选完再点击2" class="headerlink" title="· 安装：勾选完再点击2 "></a>· 安装：勾选完再点击2 <img src="/img/python_install/安装1.png" alt="两个都勾选"></h2><h2 id="·-继续勾选，勾选完点next"><a href="#·-继续勾选，勾选完点next" class="headerlink" title="· 继续勾选，勾选完点next"></a>· 继续勾选，勾选完点next<img src="/img/python_install/2.png" alt="全部勾选上"></h2><h2 id="·-接着继续"><a href="#·-接着继续" class="headerlink" title="· 接着继续   "></a>· 接着继续   <img src="/img/python_install/next.png" alt="勾选和选路径"></h2><h2 id="·-最后点击Install安装，等待安装完成"><a href="#·-最后点击Install安装，等待安装完成" class="headerlink" title="· 最后点击Install安装，等待安装完成 "></a>· 最后点击Install安装，等待安装完成 <img src="/img/python_install/finish.png" alt="至此安装完成~"></h2><h1 id="Second-下载vscode，敲代码"><a href="#Second-下载vscode，敲代码" class="headerlink" title="Second : 下载vscode，敲代码"></a>Second : 下载vscode，敲代码</h1><h2 id="·打开浏览器，输入网址"><a href="#·打开浏览器，输入网址" class="headerlink" title="·打开浏览器，输入网址:"></a>·打开浏览器，输入网址:</h2><pre><code>https://code.visualstudio.com/</code></pre><h2 id="·下载："><a href="#·下载：" class="headerlink" title="·下载："></a>·下载：<img src="/img/python_install/vscode.png" alt="下载"></h2><h2 id="·找到下载完的exe文件，然后双击安装"><a href="#·找到下载完的exe文件，然后双击安装" class="headerlink" title="·找到下载完的exe文件，然后双击安装"></a>·找到下载完的exe文件，然后双击安装<img src="/img/python_install/install_vs.png" alt="找到下载下来的exe文件"></h2><h2 id="·接着看图操作"><a href="#·接着看图操作" class="headerlink" title="·接着看图操作"></a>·接着看图操作</h2><p><img src="/img/python_install/one.png" alt="第一步"><br><img src="/img/python_install/two.png" alt="第二步"><br><img src="/img/python_install/three.png" alt="第三步"><br><img src="/img/python_install/four.png" alt="第四步"><br><img src="/img/python_install/five.png" alt="第五步"></p><h2 id="·关掉重开"><a href="#·关掉重开" class="headerlink" title="·关掉重开 "></a>·关掉重开 <img src="/img/python_install/six.png" alt="第六步"></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;First-下载python&quot;&gt;&lt;a href=&quot;#First-下载python&quot; class=&quot;headerlink&quot; title=&quot;First:下载python&quot;&gt;&lt;/a&gt;First:下载python&lt;/h1&gt;&lt;h2 id=&quot;·-打开浏览器，输入网址：&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="python" scheme="http://localhost:4000/categories/python/"/>
    
    
    <category term="python安装" scheme="http://localhost:4000/tags/python%E5%AE%89%E8%A3%85/"/>
    
    <category term="4月15号" scheme="http://localhost:4000/tags/4%E6%9C%8815%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>ync</title>
    <link href="http://localhost:4000/2023/04/14/ync-1/"/>
    <id>http://localhost:4000/2023/04/14/ync-1/</id>
    <published>2023-04-14T08:54:37.000Z</published>
    <updated>2023-11-14T12:57:53.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yncaqy"><a href="#yncaqy" class="headerlink" title="yncaqy"></a>yncaqy</h1><p>1<br>2<br>3<br>4<br>5<br>6</p><p>7<br>8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    ...<br>    <span class="hljs-string">&#x27;rest_framework&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure><p><img src="/img\2.jpg" alt="1"><br><img src="https://w.wallhaven.cc/full/9d/wallhaven-9dzr8w.png" alt="2"></p><div class="timeline green"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div><!-- <iframe src="https://www.bilibili.com/video/BV1YY4y1D76n/?share_source=copy_web&vd_source=ad238152766ff2b48ccad8c0e9945d23&t=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height=600 width=800> </iframe> --><!-- <iframe src="//player.bilibili.com/player.html?aid=653875369&bvid=BV1YY4y1D76n&cid=1070500402&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe> -->]]></content>
    
    
    <summary type="html">这是一个测试的markdown文件~</summary>
    
    
    
    <category term="python" scheme="http://localhost:4000/categories/python/"/>
    
    <category term="test" scheme="http://localhost:4000/categories/python/test/"/>
    
    
    <category term="test" scheme="http://localhost:4000/tags/test/"/>
    
    <category term="Blog" scheme="http://localhost:4000/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>AQY</title>
    <link href="http://localhost:4000/2023/04/14/AQY/"/>
    <id>http://localhost:4000/2023/04/14/AQY/</id>
    <published>2023-04-14T08:50:34.000Z</published>
    <updated>2023-11-15T07:00:40.982Z</updated>
    
    <content type="html"><![CDATA[<h4 id="DRF框架"><a href="#DRF框架" class="headerlink" title="DRF框架"></a>DRF框架</h4><h2 id="1-DRF入门"><a href="#1-DRF入门" class="headerlink" title="1 DRF入门"></a>1 DRF入门</h2><h3 id="1-1-RESTful"><a href="#1-1-RESTful" class="headerlink" title="1.1 RESTful"></a>1.1 RESTful</h3><ul><li>REST与技术无关，它是一种 <strong>软件架构风格</strong> ，REST是Representational State Transfer的简称，中文翻译为“ <strong>表征状态转移</strong> ”</li><li>REST从<strong>资源的角度</strong>类审视整个网络，它将分布在网络中某个节点的 <strong>资源通过URL进行标识</strong> ，客户端应用<strong>通过URL来获取资源</strong>的表征，获得这些表征致使这些应用转变状态</li><li>所有的数据，不管是通过网络获取的还是操作(增删改查)的数据，都是资源，<strong>将一切数据视为资源</strong>是REST区别与其他架构风格的最本质属性</li><li>对于REST这种面向资源的架构风格，有人提出一种全新的结构理念，即： <strong>面向资源架构</strong> （ROA：Resource Oriented Architecture）</li></ul><h3 id="1-2-API接口和-RESTful-API规范"><a href="#1-2-API接口和-RESTful-API规范" class="headerlink" title="1.2 API接口和 RESTful API规范"></a>1.2 API接口和 RESTful API规范</h3><p>1.2.1 API接口</p><ul><li>规定了前端和后端交互规则的URL连接，也就是前后端交互的媒介</li></ul><p>1.2.2 为什么要有规范</p><ul><li>为了在团队中达成共识、防止个人习惯差异引起的混乱</li><li>需要一个大家都认可的规范，减少合作成本</li></ul><p>1.2.3 API接口文档</p><ul><li>编写接口的用户、使用方法、数据格式等等</li><li>可以使用书写、或者使用工具自动生成（coreapi,swagger)</li></ul><p>1.2.4 RESTful API规范</p><ul><li>必须通过http来传输数据</li><li>必须api标志：<a href="http://localhost:8080/api/xxx">http://localhost:8080/api/xxx</a></li><li>接口中要提现接口版本：<a href="http://localhost:8080/api/v1/books">http://localhost:8080/api/v1/books</a></li><li>通过请求方法的不通来区分操作：<ul><li>查询：GET</li><li>POST：新增和提交数据</li><li>PUT：修改数据</li><li>PATCH：局部修改数据</li><li>DELETE：删除数据</li></ul></li><li>请求路径中带过滤，在URL后面带参数：<a href="https://api.example.com/v1/?name=&#39;金&#39;&amp;order=asc">https://api.example.com/v1/?name=&#39;金&#39;&amp;order=asc</a></li><li>返回响应数据中携带响应状态码</li><li>返回数据中携带错误信息：{error : ‘错误信息’}</li><li>针对不同操作，返回数据符合以下规范：<ul><li>GET /books ：返回资源对象的列表</li><li>GET /books/1 ：返回id为1的单个资源对象</li><li>POST /boos：返回新生成的资源对象</li><li>PUT /books/1：返回修改后的完整的资源对象</li><li>PATCH /books/1：返回修改后端完整的资源对象</li><li>DELETE /books/1：返回一个空文档</li></ul></li><li>返回结果中写在资源连接：{“name”:”zhangsan”, “url”:”<a href="http://www.xx.xx.com/xxx&quot;}">http://www.xx.xx.com/xxx&quot;}</a></li></ul><h3 id="1-3-Django-RESTful介绍与安装"><a href="#1-3-Django-RESTful介绍与安装" class="headerlink" title="1.3 Django-RESTful介绍与安装"></a>1.3 Django-RESTful介绍与安装</h3><h4 id="1-3-1-介绍"><a href="#1-3-1-介绍" class="headerlink" title="1.3.1 介绍"></a>1.3.1 介绍</h4><ul><li>Django rest_framework, 简称 drf, 可以更方便的使用django写出符合 RESTful 规范的接口, (缩减编写api接口的代码)</li></ul><blockquote><ul><li>Django REST framework是一个建立在Django基础之上的Web应用开发框架(Django的一个app)，可以快速的开发REST API接口应用</li><li>在REST framework中，提供了序列化器Serialzier的定义，可以帮助我们简化序列化与反序列化的过程</li><li>不仅如此，还提供丰富的类视图、扩展类、视图集来简化视图的编写工作</li><li>REST framework还提供了认证、权限、限流、过滤、分页、接口文档等功能支持</li><li>REST framework提供了一个API 的Web可视化界面来方便查看测试接口</li></ul></blockquote><ul><li><a href="https://www.django-rest-framework.org/">官方文档 : https://www.django-rest-framework.org/</a></li><li><a href="https://github.com/encode/django-rest-framework/tree/master">GitHub : https://github.com/encode/django-rest-framework/tree/master</a></li></ul><h4 id="1-3-2-安装DRF"><a href="#1-3-2-安装DRF" class="headerlink" title="1.3.2 安装DRF"></a>1.3.2 安装DRF</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip install djangorestframework<br></code></pre></td></tr></table></figure><h4 id="1-3-3-配置DRF"><a href="#1-3-3-配置DRF" class="headerlink" title="1.3.3 配置DRF"></a>1.3.3 配置DRF</h4><p>在settings.py中添加app</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">INSTALLED_APPS = [<br>    ...<br>    &#x27;rest_framework&#x27;,<br>]<br></code></pre></td></tr></table></figure><p>1.3.4 models.py中书写模型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from django.db import models<br>class Book(models.Model):<br>    nid = models.AutoField(primary_key=True)<br>    title = models.CharField(max_length=32)<br>    price = models.DecimalField(max_digits=8,decimal_places=2)<br>    author = models.CharField(max_length=16)<br>    publish = models.CharField(max_length=16)<br>    # 创建好模型类执行数据库迁移命令<br></code></pre></td></tr></table></figure><h4 id="1-3-4-serializer-py新建一个序列化类（该文件也自己创建）"><a href="#1-3-4-serializer-py新建一个序列化类（该文件也自己创建）" class="headerlink" title="1.3.4 serializer.py新建一个序列化类（该文件也自己创建）"></a>1.3.4 serializer.py新建一个序列化类（该文件也自己创建）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.serializers import ModelSerializer<br>from drf_test import models<br>class BookSerializers(ModelSerializer):<br>    class Meta:<br>        model = models.Book # 指明该序列化器处理的数据字段从模型类Book参考生成<br>        fields = &quot;__all__&quot; # 指明该序列化器包含模型类中的哪些字段，’all‘指明包含所有字段<br><br></code></pre></td></tr></table></figure><h4 id="1-3-5-视图类"><a href="#1-3-5-视图类" class="headerlink" title="1.3.5 视图类"></a>1.3.5 视图类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from django.shortcuts import render<br>from rest_framework.viewsets import ModelViewSet<br>from drf_test.serializers import BookSerializers<br>from drf_test import models<br><br>class BookView(ModelViewSet):<br>    serializer_class = BookSerializers # 指明该视图在进行序列化或反序列化时使用的序列化器<br>    queryset = models.Book.objects.all() # 指明该视图集在查询数据时使用的查询集<br></code></pre></td></tr></table></figure><h4 id="1-3-6-编写路由"><a href="#1-3-6-编写路由" class="headerlink" title="1.3.6 编写路由"></a>1.3.6 编写路由</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from django.contrib import admin<br>from django.urls import path<br>from rest_framework.routers import SimpleRouter<br>from drf_test import views<br>router = SimpleRouter() # 用来处理视图的路由器<br>router.register(&#x27;book&#x27;,views.BookView) # 在路由器中注册视图集<br>urlpatterns = [<br>    path(&#x27;admin/&#x27;, admin.site.urls),<br>]<br>urlpatterns += router.urls # 将路由器中的所有路由信息拼接到Django中的路由列表中<br></code></pre></td></tr></table></figure><h4 id="1-3-7-启动项目开始测试"><a href="#1-3-7-启动项目开始测试" class="headerlink" title="1.3.7 启动项目开始测试"></a>1.3.7 启动项目开始测试</h4><p>POST：添加一本书</p><p>GET：获取图书</p><h2 id="2-DRF功能组件"><a href="#2-DRF功能组件" class="headerlink" title="2 DRF功能组件"></a>2 DRF功能组件</h2><h3 id="2-1-认证Authentication"><a href="#2-1-认证Authentication" class="headerlink" title="2.1 认证Authentication"></a>2.1 认证Authentication</h3><h4 id="2-1-1-认证配置"><a href="#2-1-1-认证配置" class="headerlink" title="2.1.1 认证配置"></a>2.1.1 认证配置</h4><p>在配置文件中配置全局默认的认证方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: (<br>        &#x27;rest_framework.authentication.BasicAuthentication&#x27;,   # 基本认证<br>        &#x27;rest_framework.authentication.SessionAuthentication&#x27;,  # session认证<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在每个视图中通过设置authentication_classes属性来设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.authentication import SessionAuthentication, BasicAuthentication<br>from rest_framework.views import APIView<br><br>class ExampleView(APIView):<br>    authentication_classes = (SessionAuthentication, BasicAuthentication)<br>    ...<br></code></pre></td></tr></table></figure><p>认证失败会有两种可能的返回值</p><ul><li>401 Unauthorized 未认证</li><li>403 Permission Denied 权限被禁止</li></ul><p>权限Permissions</p><p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p><ul><li>在执行视图的dispatch()方法前，会先进行视图访问权限的判断</li><li>在通过get_object()获取具体对象时，会进行模型对象访问权限的判断</li></ul><h4 id="2-1-2-认证使用"><a href="#2-1-2-认证使用" class="headerlink" title="2.1.2 认证使用"></a>2.1.2 认证使用</h4><p>可以在配置文件中设置默认的权限管理类，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: (<br>        &#x27;rest_framework.permissions.IsAuthenticated&#x27;,<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>如果未指明，则采用如下默认配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;: (<br>   &#x27;rest_framework.permissions.AllowAny&#x27;,<br>)<br></code></pre></td></tr></table></figure><p>也可以在具体的视图中通过permission_casses属性来设置，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.permissions import IsAuthenticated<br>from rest_framework.views import APIView<br><br>class ExampleView(APIView):<br>    permission_classes = (IsAuthenticated,)<br>    ...<br></code></pre></td></tr></table></figure><h4 id="2-1-3-提供的权限"><a href="#2-1-3-提供的权限" class="headerlink" title="2.1.3 提供的权限"></a>2.1.3 提供的权限</h4><ul><li>AllowAny 允许所有用户</li><li>IsAuthenticated 仅通过认证的用户</li><li>IsAdminUser 仅管理员用户</li><li>IsAuthenticatedOrReadOnly 已经登陆认证的用户可以对数据进行增删改操作，没有登陆认证的只能查看数据。</li></ul><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.authentication import SessionAuthentication<br>from rest_framework.permissions import IsAuthenticated<br>from rest_framework.generics import RetrieveAPIView<br><br>class BookDetailView(RetrieveAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br>    authentication_classes = [SessionAuthentication]<br>    permission_classes = [IsAuthenticated]<br></code></pre></td></tr></table></figure><h4 id="2-1-4-自定义权限"><a href="#2-1-4-自定义权限" class="headerlink" title="2.1.4 自定义权限"></a>2.1.4 自定义权限</h4><p>如需自定义权限，需继承rest_framework.permissions.BasePermission父类，并实现以下两个任何一个方法或全部</p><ul><li><code>.has_permission(self, request, view)</code><br>是否可以访问视图， view表示当前视图对象</li><li><code>.has_object_permission(self, request, view, obj)</code><br>是否可以访问数据对象， view表示当前视图， obj为数据对象</li></ul><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class MyPermission(BasePermission):<br>    def has_object_permission(self, request, view, obj):<br>        &quot;&quot;&quot;控制对obj对象的访问权限，此案例决绝所有对对象的访问&quot;&quot;&quot;<br>        return False<br><br>class BookInfoViewSet(ModelViewSet):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br>    permission_classes = [IsAuthenticated, MyPermission]<br></code></pre></td></tr></table></figure><h3 id="2-2-限流Throttling"><a href="#2-2-限流Throttling" class="headerlink" title="2.2 限流Throttling"></a>2.2 限流Throttling</h3><h4 id="2-2-1-限流介绍"><a href="#2-2-1-限流介绍" class="headerlink" title="2.2.1 限流介绍"></a>2.2.1 限流介绍</h4><p>可以对接口访问的频次进行限制，以减轻服务器压力。</p><p>一般用于付费购买次数,投票等场景使用.</p><h4 id="2-2-2-限流使用"><a href="#2-2-2-限流使用" class="headerlink" title="2.2.2 限流使用"></a>2.2.2 限流使用</h4><p>可以在配置文件中，使用DEFAULT_THROTTLE_CLASSES和DEFAULT_THROTTLE_RATES进行全局配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: (<br>        &#x27;rest_framework.throttling.AnonRateThrottle&#x27;,<br>        &#x27;rest_framework.throttling.UserRateThrottle&#x27;<br>    ),<br>    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;<br>        &#x27;anon&#x27;: &#x27;100/day&#x27;,<br>        &#x27;user&#x27;: &#x27;1000/day&#x27;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DEFAULT_THROTTLE_RATES</code> 可以使用 <code>second</code>, <code>minute</code>, <code>hour</code> 或 <code>day</code>来指明周期。</p><p>也可以在具体视图中，通过throttle_classes属性来配置，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.throttling import UserRateThrottle<br>from rest_framework.views import APIView<br><br>class ExampleView(APIView):<br>    throttle_classes = (UserRateThrottle,)<br>    ...<br></code></pre></td></tr></table></figure><h4 id="2-2-3-可选限流类"><a href="#2-2-3-可选限流类" class="headerlink" title="2.2.3 可选限流类"></a>2.2.3 可选限流类</h4><p>1） AnonRateThrottle</p><p>限制所有匿名未认证用户，使用IP区分用户。</p><p>使用 <code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code> 来设置频次</p><p>2）UserRateThrottle</p><p>限制认证用户，使用User id 来区分。</p><p>使用 <code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code> 来设置频次</p><p>3）ScopedRateThrottle</p><p>限制用户对于每个视图的访问频次，使用ip或user id。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class ContactListView(APIView):<br>    throttle_scope = &#x27;contacts&#x27;<br>    ...<br><br>class ContactDetailView(APIView):<br>    throttle_scope = &#x27;contacts&#x27;<br>    ...<br><br>class UploadView(APIView):<br>    throttle_scope = &#x27;uploads&#x27;<br>    ...<br>REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_THROTTLE_CLASSES&#x27;: (<br>        &#x27;rest_framework.throttling.ScopedRateThrottle&#x27;,<br>    ),<br>    &#x27;DEFAULT_THROTTLE_RATES&#x27;: &#123;<br>        &#x27;contacts&#x27;: &#x27;1000/day&#x27;,<br>        &#x27;uploads&#x27;: &#x27;20/day&#x27;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-案例"><a href="#2-2-4-案例" class="headerlink" title="2.2.4 案例"></a>2.2.4 案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.authentication import SessionAuthentication<br>from rest_framework.permissions import IsAuthenticated<br>from rest_framework.generics import RetrieveAPIView<br>from rest_framework.throttling import UserRateThrottle<br><br>class BookDetailView(RetrieveAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br>    authentication_classes = [SessionAuthentication]<br>    permission_classes = [IsAuthenticated]<br>    throttle_classes = (UserRateThrottle,)<br></code></pre></td></tr></table></figure><h3 id="2-3-过滤Filtering"><a href="#2-3-过滤Filtering" class="headerlink" title="2.3 过滤Filtering"></a>2.3 过滤Filtering</h3><h4 id="2-3-1-基本用法"><a href="#2-3-1-基本用法" class="headerlink" title="2.3.1 基本用法"></a>2.3.1 基本用法</h4><p>对于列表数据，可能需求根据字典及逆行过滤，我们可以通过添加django-filter扩展来增强支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip install django-filter<br><br># 从数据库中查询数据的过滤<br>select * from t_emp where name=&#x27;zs&#x27; and sal=2000<br></code></pre></td></tr></table></figure><p>在配置文件中增加过滤后端的设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">INSTALLED_APPS = [<br>    ...<br>    &#x27;django_filters&#x27;,  # 需要注册应用，<br>]<br><br>REST_FRAMEWORK = &#123;<br>    ...<br>    &#x27;DEFAULT_FILTER_BACKENDS&#x27;: (&#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;,)<br>&#125;<br></code></pre></td></tr></table></figure><p>在视图中添加filter_fields属性，指定可以过滤的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookListView(ListAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br>    filter_fields = (&#x27;btitle&#x27;, &#x27;bread&#x27;)<br><br># 127.0.0.1:8000/books/?btitle=西游记<br></code></pre></td></tr></table></figure><h4 id="2-3-2-排序"><a href="#2-3-2-排序" class="headerlink" title="2.3.2 排序"></a>2.3.2 排序</h4><p>对于列表数据，REST framework提供了OrderingFileter过滤器来帮助我们快速指明数据按照指定字段进行排序</p><p>用法</p><p>在类视图中设置filter_backends，使用 <code>rest_framework.filters.OrderingFilter</code>过滤器，REST framework会在请求的查询字符串参数中检查是否包含了ordering参数，如果包含了ordering参数，则按照ordering参数指明的排序字段对数据集进行排序。</p><p>前端可以传递的ordering参数的可选字段值需要在ordering_fields中指明。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookListView(ListAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br>    filter_backends = [OrderingFilter]<br>    ordering_fields = (&#x27;id&#x27;, &#x27;bread&#x27;, &#x27;bpub_date&#x27;)<br><br># 127.0.0.1:8000/books/?ordering=-bread<br></code></pre></td></tr></table></figure><h3 id="2-4-分页"><a href="#2-4-分页" class="headerlink" title="2.4 分页"></a>2.4 分页</h3><h4 id="2-4-1-基本用法"><a href="#2-4-1-基本用法" class="headerlink" title="2.4.1 基本用法"></a>2.4.1 基本用法</h4><p>REST framework提供了分页的支持。</p><p>我们可以在配置文件中设置全局的分页方式，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_PAGINATION_CLASS&#x27;:  &#x27;rest_framework.pagination.PageNumberPagination&#x27;,<br>    &#x27;PAGE_SIZE&#x27;: 100  # 每页数目<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以通过自定义Pagination类，来未视图添加不通分页行为。在视图中通过Pagination_clas属性来指明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class LargeResultsSetPagination(PageNumberPagination):<br>    page_size = 1000<br>    page_size_query_param = &#x27;page_size&#x27;<br>    max_page_size = 10000<br>class BookDetailView(RetrieveAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br>    pagination_class = LargeResultsSetPagination<br></code></pre></td></tr></table></figure><p>注意：如果在视图内关闭分页功能，可以按照下面的代码进行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pagination_class = None<br></code></pre></td></tr></table></figure><h4 id="2-4-2-可选分页器"><a href="#2-4-2-可选分页器" class="headerlink" title="2.4.2 可选分页器"></a>2.4.2 可选分页器</h4><p>1） <strong>PageNumberPagination</strong></p><p>前端访问网址形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">GET  http://api.example.org/books/?page=4<br></code></pre></td></tr></table></figure><p>可以在子类中定义的属性：</p><ul><li>page_size 每页数目</li><li>page_query_param 前端发送的页数关键字名，默认为”page”</li><li>page_size_query_param 前端发送的每页数目关键字名，默认为None</li><li>max_page_size 前端最多能设置的每页数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.pagination import PageNumberPagination<br><br>class StandardPageNumberPagination(PageNumberPagination):<br>    page_size_query_param = &#x27;page_size&#x27;<br>    max_page_size = 10<br><br>class BookListView(ListAPIView):<br>    queryset = BookInfo.objects.all().order_by(&#x27;id&#x27;)<br>    serializer_class = BookInfoSerializer<br>    pagination_class = StandardPageNumberPagination<br><br># 127.0.0.1/books/?page=1&amp;page_size=2<br></code></pre></td></tr></table></figure><p>2）<strong>LimitOffsetPagination</strong></p><p>前端访问网址形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">GET http://api.example.org/books/?limit=100&amp;offset=400<br></code></pre></td></tr></table></figure><p>可以在子类中定义的属性：</p><ul><li>default_limit 默认限制，默认值与 <code>PAGE_SIZE</code>设置一直</li><li>limit_query_param limit参数名，默认’limit’</li><li>offset_query_param offset参数名，默认’offset’</li><li>max_limit 最大limit限制，默认None</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.pagination import LimitOffsetPagination<br><br>class BookListView(ListAPIView):<br>    queryset = BookInfo.objects.all().order_by(&#x27;id&#x27;)<br>    serializer_class = BookInfoSerializer<br>    pagination_class = LimitOffsetPagination<br><br># 127.0.0.1:8000/books/?offset=3&amp;limit=2<br></code></pre></td></tr></table></figure><h3 id="2-5-异常处理Exceptions"><a href="#2-5-异常处理Exceptions" class="headerlink" title="2.5 异常处理Exceptions"></a>2.5 异常处理Exceptions</h3><p>REST framework 提供了异常处理，我们可以自定义异常处理函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.views import exception_handler<br><br>def custom_exception_handler(exc, context):<br>    # 先调用REST framework默认的异常处理方法获得标准错误响应对象<br>    response = exception_handler(exc, context)<br><br>    # 在此处补充自定义的异常处理<br>    if response is not None:<br>        response.data[&#x27;status_code&#x27;] = response.status_code<br><br>    return response<br></code></pre></td></tr></table></figure><p>在配置文件中声明自定义的异常处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;EXCEPTION_HANDLER&#x27;: &#x27;my_project.my_app.utils.custom_exception_handler&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果未声明，会采用默认的方式，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;EXCEPTION_HANDLER&#x27;: &#x27;rest_framework.views.exception_handler&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如：</p><p>补充上处理关于数据库的异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.views import exception_handler as drf_exception_handler<br>from rest_framework import status<br>from django.db import DatabaseError<br><br>def exception_handler(exc, context):<br>    response = drf_exception_handler(exc, context)<br><br>    if response is None:<br>        view = context[&#x27;view&#x27;]<br>        if isinstance(exc, DatabaseError):<br>            print(&#x27;[%s]: %s&#x27; % (view, exc))<br>            response = Response(&#123;&#x27;detail&#x27;: &#x27;服务器内部错误&#x27;&#125;, status=status.HTTP_507_INSUFFICIENT_STORAGE)<br><br>    return response<br><br></code></pre></td></tr></table></figure><p>REST framework定义的异常</p><ul><li>APIException 所有异常的父类</li><li>ParseError 解析错误</li><li>AuthenticationFailed 认证失败</li><li>NotAuthenticated 尚未认证</li><li>PermissionDenied 权限决绝</li><li>NotFound 未找到</li><li>MethodNotAllowed 请求方式不支持</li><li>NotAcceptable 要获取的数据格式不支持</li><li>Throttled 超过限流次数</li><li>ValidationError 校验失败</li></ul><h3 id="2-6-自动生成接口文档"><a href="#2-6-自动生成接口文档" class="headerlink" title="2.6 自动生成接口文档"></a>2.6 自动生成接口文档</h3><p>REST framework可以自动帮助我们生成接口文档。</p><p>接口文档以网页的方式呈现。</p><p>自动接口文档能生成的是继承自 <code>APIView</code>及其子类的视图。</p><h4 id="2-6-1-安装依赖"><a href="#2-6-1-安装依赖" class="headerlink" title="2.6.1 安装依赖"></a>2.6.1 安装依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip install coreapi<br></code></pre></td></tr></table></figure><h4 id="2-6-2-设置接口文档访问路径"><a href="#2-6-2-设置接口文档访问路径" class="headerlink" title="2.6.2 设置接口文档访问路径"></a>2.6.2 设置接口文档访问路径</h4><p>在总路由中添加接口文档路径。</p><p>文档路由对应的视图配置为 <code>rest_framework.documentation.include_docs_urls</code>，</p><p>参数 <code>title</code>为接口文档网站的标题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.documentation import include_docs_urls<br><br>urlpatterns = [<br>    ...<br>    path(&#x27;docs/&#x27;, include_docs_urls(title=&#x27;站点页面标题&#x27;))<br>]<br></code></pre></td></tr></table></figure><p>需要在配置文件settings.py中指定schema_class的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_SCHEMA_CLASS&#x27;: &#x27;rest_framework.schemas.coreapi.AutoSchema&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-3-文档描述说明的定义位置"><a href="#2-6-3-文档描述说明的定义位置" class="headerlink" title="2.6.3 文档描述说明的定义位置"></a>2.6.3 文档描述说明的定义位置</h4><p>(1)单一方法的视图，可直接使用类视图的文档字符串，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookListView(generics.ListAPIView):<br>    &quot;&quot;&quot;<br>    返回所有图书信息.<br>    &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>(2) 包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookListCreateView(generics.ListCreateAPIView):<br>    &quot;&quot;&quot;<br>    get:<br>    返回所有图书信息.<br><br>    post:<br>    新建图书.<br>    &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>(3) 对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):<br>    &quot;&quot;&quot;<br>    list:<br>    返回图书列表数据<br><br>    retrieve:<br>    返回图书详情数据<br><br>    latest:<br>    返回最新的图书数据<br><br>    read:<br>    修改图书的阅读量<br>    &quot;&quot;&quot;<br></code></pre></td></tr></table></figure><h4 id="2-6-4-访问接口文档网页"><a href="#2-6-4-访问接口文档网页" class="headerlink" title="2.6.4 访问接口文档网页"></a>2.6.4 访问接口文档网页</h4><p>1） 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read</p><p>2）参数的Description需要在模型类或序列化器类的字段中以help_text选项定义，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfo(models.Model):<br>    ...<br>    bread = models.IntegerField(default=0, verbose_name=&#x27;阅读量&#x27;, help_text=&#x27;阅读量&#x27;)<br>    ...<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookReadSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = BookInfo<br>        fields = (&#x27;bread&#x27;, )<br>        extra_kwargs = &#123;<br>            &#x27;bread&#x27;: &#123;<br>                &#x27;required&#x27;: True,<br>                &#x27;help_text&#x27;: &#x27;阅读量&#x27;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="3-DRF视图家族"><a href="#3-DRF视图家族" class="headerlink" title="3 DRF视图家族"></a>3 DRF视图家族</h2><p>Django REST framwork 提供的视图的主要作用：</p><ul><li>控制序列化器的执行（检验、保存、转换数据）</li><li>控制数据库查询的执行</li></ul><h3 id="3-1-两个视图基类"><a href="#3-1-两个视图基类" class="headerlink" title="3.1 两个视图基类"></a>3.1 两个视图基类</h3><p>APIView和GenericAPIView</p><h4 id="3-1-1-APIView"><a href="#3-1-1-APIView" class="headerlink" title="3.1.1 APIView"></a>3.1.1 APIView</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">rest_framework.views.APIView<br></code></pre></td></tr></table></figure><p>APIView是REST framework提供的所有视图的基类，继承自Django的View父类</p><p>APIView 与 View 的不同之处在于：</p><ul><li>传入到视图方法中的是REST framework的 <code>Request</code>对象，而不是Django的 <code>HttpRequeset</code>对象；</li><li>视图方法可以返回REST framework的 <code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式；</li><li>任何 <code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li><li>在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。</li></ul><p>支持定义的属性</p><ul><li><strong>authentication_classes</strong> 列表或元祖，身份认证类</li><li><strong>permissoin_classes</strong> 列表或元祖，权限检查类</li><li><strong>throttle_classes</strong> 列表或元祖，流量控制类</li></ul><p>在 <code>APIView</code>中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.views import APIView<br>from rest_framework.response import Response<br><br># url(r&#x27;^books/$&#x27;, views.BookListView.as_view()),<br>class BookListView(APIView):<br>    def get(self, request):<br>        books = BookInfo.objects.all()<br>        serializer = BookInfoSerializer(books, many=True)<br>        return Response(serializer.data)<br></code></pre></td></tr></table></figure><h4 id="3-1-2-GenericAPIView"><a href="#3-1-2-GenericAPIView" class="headerlink" title="3.1.2 GenericAPIView"></a>3.1.2 GenericAPIView</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">rest_framework.generics.GenericAPIView<br></code></pre></td></tr></table></figure><p>继承自 <code>APIVIew</code>，主要增加了操作序列化器和数据库查询的方法，作用是为下面Mixin扩展类的执行提供方法支持。通常在使用时，可搭配一个或多个Mixin扩展类。</p><p><strong>提供的关于序列化器使用的属性与方法</strong></p><ul><li><p>属性：</p><ul><li>serializer_class 指明视图使用的序列化器</li></ul></li><li><p>方法：</p><ul><li>get_serializer_class(self)<br>当出现一个视图类中调用多个序列化器时，那么可以通过条件来判断在get_serializer_class方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了。<br>返回序列化器类，默认返回serializer_class，可以重写，例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def get_serializer_class(self):<br>    if self.request.user.is_staff:<br>        return FullAccountSerializer<br>    return BasicAccountSerializer<br></code></pre></td></tr></table></figure></li></ul></li><li><p>get_serializer(self, args, *kwargs)</p><p>返回序列化器对象，主要用来提供给Mixin扩展类使用，如果我们在视图中想要获取序列化器对象，也可以直接调用此方法。</p><p>注意，该方法在提供序列化器对象的时候，会向序列化器对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。</p><ul><li>request 当前视图的请求对象</li><li>view 当前请求的类视图对象</li><li>format 当前请求期望返回的数据格式</li></ul></li></ul><p><strong>提供的关于数据库查询的属性与方法</strong></p><p>属性：</p><ul><li>queryset 指明使用的数据查询集</li></ul><p>方法：</p><ul><li><p>get_queryset(self)<br>返回视图使用的查询集，主要用来提供给Mixin扩展类使用，是列表视图与详情视图获取数据的基础，默认返回queryset属性，可以重写，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def get_queryset(self):<br>    user = self.request.user<br>    return user.accounts.all()<br></code></pre></td></tr></table></figure></li><li><p>get_boject(self)</p><p>返回详情视图所需的模型类数据对象，主要用来提供给Mixin扩展类使用。<br>在视图中可以调用该方法获取详情信息的模型类对象。<br>若详情访问的模型类对象不存在，会返回404。<br>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookDetailView.as_view()),<br>class BookDetailView(GenericAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br><br>    def get(self, request, pk):<br>        book = self.get_object() # get_object()方法根据pk参数查找queryset中的数据对象<br>        serializer = self.get_serializer(book)<br>        return Response(serializer.data)<br></code></pre></td></tr></table></figure></li></ul><p>其他可以设置的属性</p><ul><li><strong>pagination_class</strong> 指明分页控制类</li><li><strong>filter_backends</strong> 指明过滤控制后端</li></ul><h4 id="3-1-3-DRF的请求对象"><a href="#3-1-3-DRF的请求对象" class="headerlink" title="3.1.3 DRF的请求对象"></a>3.1.3 DRF的请求对象</h4><p>REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的<strong>Request</strong>类的对象。</p><p>REST framework 提供了<strong>Parser</strong>解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON、表单等）将请求数据进行parse解析，解析为类字典[QueryDict]对象保存到<strong>Request</strong>对象中。</p><h5 id="1）-data"><a href="#1）-data" class="headerlink" title="1）.data"></a>1）.data</h5><p><code>request.data</code> 返回解析之后的请求体数据。类似于Django中标准的 <code>request.POST</code>和 <code>request.FILES</code>属性，但提供如下特性：</p><ul><li>包含了解析之后的文件和非文件数据</li><li>包含了对POST、PUT、PATCH请求方式解析后的数据</li><li>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</li></ul><h5 id="2）-query-params"><a href="#2）-query-params" class="headerlink" title="2）.query_params"></a>2）.query_params</h5><p><code>request.query_params</code>与Django标准的 <code>request.GET</code>相同，只是更换了更正确的名称而已。</p><h5 id="3）request-request"><a href="#3）request-request" class="headerlink" title="3）request._request"></a>3）request._request</h5><p>获取django封装的Request对象</p><p><strong>注意：要使用drf提供的Request请求处理对象，必须在编写视图类时继承drf提供的视图基类<br>from rest_framework.views import APIView</strong></p><h4 id="3-1-4-DRF的响应对象"><a href="#3-1-4-DRF的响应对象" class="headerlink" title="3.1.4 DRF的响应对象"></a>3.1.4 DRF的响应对象</h4><p>REST framework提供了一个响应类 <code>Response</code>，使用该类构造响应对象时，响应的具体数据内容会被转换（render渲染器）成符合前端需求的类型。</p><p>REST framework提供了 <code>Renderer</code> 渲染器，用来根据请求头中的 <code>Accept</code>（接收数据类型声明）来自动转换响应数据到对应格式。如果前端请求中未进行Accept声明，则会采用Content-Type方式处理响应数据，我们可以通过配置来修改默认响应格式。</p><p>可以在<strong>rest_framework.settings</strong>查找所有的drf默认配置项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    &#x27;DEFAULT_RENDERER_CLASSES&#x27;: (  # 默认响应渲染类<br>        &#x27;rest_framework.renderers.JSONRenderer&#x27;,  # json渲染器，返回json数据<br>        &#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;,  # 浏览器API渲染器，返回调试界面<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1）response的构造方式"><a href="#1）response的构造方式" class="headerlink" title="1）response的构造方式"></a>1）response的构造方式</h5><p>Response(data, status=None, template_name=None, headers=None, content_type=None)</p><p><code>data</code>数据不要是render处理之后的数据，只需传递python的内建类型数据即可，REST framework会使用 <code>renderer</code>渲染器处理 <code>data</code>。</p><p><code>data</code>不能是复杂结构的数据，如Django的模型类对象，对于这样的数据我们可以使用 <code>Serializer</code>序列化器序列化处理后（转为了Python字典类型）再传递给 <code>data</code>参数。</p><p>参数说明：</p><blockquote><ul><li><code>data</code>: 为响应准备的序列化处理后的数据；</li><li><code>status</code>: 状态码，默认200；</li><li><code>template_name</code>: 模板名称，如果使用 <code>HTMLRenderer</code> 时需指明；</li><li><code>headers</code>: 用于存放响应头信息的字典；</li><li><code>content_type</code>: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数</li></ul></blockquote><h5 id="2）response对象的状态码"><a href="#2）response对象的状态码" class="headerlink" title="2）response对象的状态码"></a>2）response对象的状态码</h5><p>为了方便设置状态码，REST framewrok在 <code>rest_framework.status</code>模块中提供了常用http状态码的常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 1）信息告知 - 1xx<br>HTTP_100_CONTINUE<br>HTTP_101_SWITCHING_PROTOCOLS<br><br># 2）成功 - 2xx<br>HTTP_200_OK<br>HTTP_201_CREATED<br>HTTP_202_ACCEPTED<br>HTTP_203_NON_AUTHORITATIVE_INFORMATION<br>HTTP_204_NO_CONTENT<br>HTTP_205_RESET_CONTENT<br>HTTP_206_PARTIAL_CONTENT<br>HTTP_207_MULTI_STATUS<br><br># 3）重定向 - 3xx<br>HTTP_300_MULTIPLE_CHOICES<br>HTTP_301_MOVED_PERMANENTLY<br>HTTP_302_FOUND<br>HTTP_303_SEE_OTHER<br>HTTP_304_NOT_MODIFIED<br>HTTP_305_USE_PROXY<br>HTTP_306_RESERVED<br>HTTP_307_TEMPORARY_REDIRECT<br><br># 4）客户端错误 - 4xx<br>HTTP_400_BAD_REQUEST<br>HTTP_401_UNAUTHORIZED<br>HTTP_402_PAYMENT_REQUIRED<br>HTTP_403_FORBIDDEN<br>HTTP_404_NOT_FOUND<br>HTTP_405_METHOD_NOT_ALLOWED<br>HTTP_406_NOT_ACCEPTABLE<br>HTTP_407_PROXY_AUTHENTICATION_REQUIRED<br>HTTP_408_REQUEST_TIMEOUT<br>HTTP_409_CONFLICT<br>HTTP_410_GONE<br>HTTP_411_LENGTH_REQUIRED<br>HTTP_412_PRECONDITION_FAILED<br>HTTP_413_REQUEST_ENTITY_TOO_LARGE<br>HTTP_414_REQUEST_URI_TOO_LONG<br>HTTP_415_UNSUPPORTED_MEDIA_TYPE<br>HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE<br>HTTP_417_EXPECTATION_FAILED<br>HTTP_422_UNPROCESSABLE_ENTITY<br>HTTP_423_LOCKED<br>HTTP_424_FAILED_DEPENDENCY<br>HTTP_428_PRECONDITION_REQUIRED<br>HTTP_429_TOO_MANY_REQUESTS<br>HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE<br>HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS<br><br># 5）服务器错误 - 5xx<br>HTTP_500_INTERNAL_SERVER_ERROR<br>HTTP_501_NOT_IMPLEMENTED<br>HTTP_502_BAD_GATEWAY<br>HTTP_503_SERVICE_UNAVAILABLE<br>HTTP_504_GATEWAY_TIMEOUT<br>HTTP_505_HTTP_VERSION_NOT_SUPPORTED<br>HTTP_507_INSUFFICIENT_STORAGE<br>HTTP_511_NETWORK_AUTHENTICATION_REQUIRED<br></code></pre></td></tr></table></figure><h4 id="3-1-5-视图类源码解析"><a href="#3-1-5-视图类源码解析" class="headerlink" title="3.1.5 视图类源码解析"></a>3.1.5 视图类源码解析</h4><h5 id="1、View类的源码解析"><a href="#1、View类的源码解析" class="headerlink" title="1、View类的源码解析"></a>1、View类的源码解析</h5><p>View类核心代码在as_view和dispatch方法中，其中as_view是类方法（@classonlymethod），只能通过类调用，不能通过对象调用，它是类视图的入口点。注意这里调用的时候是通过类名.as_view()调用的。</p><p>其中，as_view方法主要执行逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># path(&#x27;books/&#x27;, views.BookViwe.as_view())<br># views.BookViwe.as_view()的执行结果，是函数内存地址----》view这个函数的内存地址<br># 请求来了---》路由匹配成功----》会执行 这个函数---》view(request)<br># view----》self.dispatch(request)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classonlymethod</span><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">as_view</span>(<span class="hljs-params">cls, **initkwargs</span>):<br>     <span class="hljs-string">&quot;&quot;&quot;Main entry point for a request-response process.&quot;&quot;&quot;</span><br>     <span class="hljs-comment"># 参数检查</span><br>     <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> initkwargs:<br>     <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> cls.http_method_names: <span class="hljs-comment"># 参数名不能是指定http的方法名</span><br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;You tried to pass in the %s method name as a &quot;</span><br>             <span class="hljs-string">&quot;keyword argument to %s(). Don&#x27;t do that.&quot;</span><br>             % (key, cls.__name__))<br>  <br>      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, key): <span class="hljs-comment"># 参数名必须是类已有属性</span><br> <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;%s() received an invalid keyword %r. as_view &quot;</span><br> <span class="hljs-string">&quot;only accepts arguments that are already &quot;</span><br> <span class="hljs-string">&quot;attributes of the class.&quot;</span> % (cls.__name__, key))<br><br>    <span class="hljs-comment"># 视图处理函数</span><br>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">request, *args, **kwargs</span>):<br>        self = cls(**initkwargs) <span class="hljs-comment"># 实例化当前类的对象</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;get&#x27;</span>) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;head&#x27;</span>):<br>            self.head = self.get<br>        self.setup(request, *args, **kwargs)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(self, <span class="hljs-string">&#x27;request&#x27;</span>):<br>             <span class="hljs-keyword">raise</span> AttributeError(<br>             <span class="hljs-string">&quot;%s instance has no &#x27;request&#x27; attribute. Did you override &quot;</span><br>             <span class="hljs-string">&quot;setup() and forget to call super()?&quot;</span> % cls.__name__<br>             )<br>        <span class="hljs-comment"># 方法派发</span><br>        <span class="hljs-keyword">return</span> self.dispatch(request, *args, **kwargs)<br>     view.view_class = cls<br>     view.view_initkwargs = initkwargs<br>  <br>     <span class="hljs-comment"># take name and docstring from class</span><br>     update_wrapper(view, cls, updated=())<br>     <span class="hljs-comment"># and possible attributes set by decorators</span><br>     <span class="hljs-comment"># like csrf_exempt from dispatch</span><br>     update_wrapper(view, cls.dispatch, assigned=())<br>     <span class="hljs-keyword">return</span> view <span class="hljs-comment"># 返回视图函数</span><br><br></code></pre></td></tr></table></figure><p>整个as_view方法是一个装饰器函数，它返回内部函数view，所以as_view()执行其实就是内部函数view执行。内部函数view主要逻辑就是：as_view()=&gt;view()=&gt;dispatch()=&gt;相应的http方法</p><p>dispatch方法是实例函数，它的主要代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dispatch---》你是什么请求，就会执行视图类中请求名字的方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>     <span class="hljs-comment">#检查请求方法是不是在http_method_names中包含</span><br>     <span class="hljs-comment">#http_method_names包括八种方法：[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;patch&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, </span><br>     <span class="hljs-comment">#&#x27;options&#x27;, &#x27;trace&#x27;]</span><br>     <span class="hljs-keyword">if</span> request.method.lower() <span class="hljs-keyword">in</span> self.http_method_names:<br>     handler = <span class="hljs-built_in">getattr</span>(self, request.method.lower(), self.http_method_not_allowed)<br>     <span class="hljs-keyword">else</span>: <span class="hljs-comment">#不在调用http_method_not_allowed报错</span><br>     handler = self.http_method_not_allowed<br>     <span class="hljs-comment">#调用和请求方法同名的实例方法处理用户请求，实例方法需要用户自己定义</span><br>     <span class="hljs-keyword">return</span> handler(request, *args, **kwargs)<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：</p><p>dispatch主要完成http请求方法的派发，调用视图类对应实例方法处理用户请求，所有用户需要定义和http请求方法同名的实例方法完成功能，所以一般CBV的模块写法是：</p><p>所以：django的CBV本质上来说就是FBV</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views <span class="hljs-keyword">import</span> View<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexView</span>(<span class="hljs-title class_ inherited__">View</span>):<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self,request</span>):<br> <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;get&quot;</span>)<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self,request</span>):<br> <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;post&quot;</span>)<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self,request</span>):<br> <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;put&quot;</span>)<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self,request</span>):<br> <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;delete&quot;</span>)<br><br></code></pre></td></tr></table></figure><h5 id="2、APIView源码解析"><a href="#2、APIView源码解析" class="headerlink" title="2、APIView源码解析"></a>2、APIView源码解析</h5><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1659679413054/b24df2eff5c841d0bec870cfdde2f951.png" alt="image.png"></p><p><strong>as_view()源码：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-meta">@classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">as_view</span>(<span class="hljs-params">cls, **initkwargs</span>):<br>        <span class="hljs-comment"># 如果他是QuerySet的一个实例</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">getattr</span>(cls, <span class="hljs-string">&#x27;queryset&#x27;</span>, <span class="hljs-literal">None</span>), models.query.QuerySet):<br>            <span class="hljs-keyword">def</span> <span class="hljs-title function_">force_evaluation</span>():<br>                <span class="hljs-comment"># 翻译：不要直接计算“.queryset”属性，因为结果将被缓存并在请求之间重用请改用“.all（）”或调用“.get_queryset（）”</span><br>                <span class="hljs-keyword">raise</span> RuntimeError(<br>                    <span class="hljs-string">&#x27;Do not evaluate the `.queryset` attribute directly, &#x27;</span><br>                    <span class="hljs-string">&#x27;as the result will be cached and reused between requests. &#x27;</span><br>                    <span class="hljs-string">&#x27;Use `.all()` or call `.get_queryset()` instead.&#x27;</span><br>                )<br>            <span class="hljs-comment"># 强制性把属性拿过来</span><br>            cls.queryset._fetch_all = force_evaluation<br>  <br><span class="hljs-comment"># 该走这里了，调用父类的as_view() --- 父类的as_view()核心是dispatch()  &gt;&gt; 跳转到dispatch()</span><br>        view = <span class="hljs-built_in">super</span>().as_view(**initkwargs)<br>        view.cls = cls<br>        view.initkwargs = initkwargs<br><br>        <span class="hljs-comment"># Note: session based authentication is explicitly CSRF validated,</span><br>        <span class="hljs-comment"># all other authentication is CSRF exempt.</span><br>  <br>        <span class="hljs-comment"># 豁免csrf检测, 返回view</span><br>        <span class="hljs-keyword">return</span> csrf_exempt(view) <span class="hljs-comment"># 函数里面套函数，这个一个装饰器！！！</span><br><br></code></pre></td></tr></table></figure><p><strong>dispatch()源码</strong></p><p>源代码代码步骤</p><ol><li>记录各个参数</li><li>initializer_request()</li><li>initial  加载各种中间件</li><li>根据得到的请求方法去处理，或处理异常</li><li>最后统一处理response</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        `.dispatch()` is pretty much the same as Django&#x27;s regular dispatch,</span><br><span class="hljs-string">        but with extra hooks for startup, finalize, and exception handling.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.args = args<br>        self.kwargs = kwargs<br>        <span class="hljs-comment"># 跳转看一看 &gt;&gt; initializer_request()</span><br>        request = self.initialize_request(request, *args, **kwargs)<br>  <br>        self.request = request<br>        self.headers = self.default_response_headers  <span class="hljs-comment"># deprecate?</span><br><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 再跳一跳 &gt;&gt; initial()</span><br>            self.initial(request, *args, **kwargs)<br><br>            <span class="hljs-comment"># Get the appropriate handler method</span><br>            <span class="hljs-comment"># 根据请求方法名字去处理</span><br>            <span class="hljs-keyword">if</span> request.method.lower() <span class="hljs-keyword">in</span> self.http_method_names:<br>                handler = <span class="hljs-built_in">getattr</span>(self, request.method.lower(),<br>                                  self.http_method_not_allowed)<br>            <span class="hljs-keyword">else</span>:<br>                handler = self.http_method_not_allowed<br><br>            response = handler(request, *args, **kwargs)<br><span class="hljs-comment"># 异常处理机制</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>            response = self.handle_exception(exc)<br><span class="hljs-comment"># 统一处理</span><br>        self.response = self.finalize_response(request, response, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> self.response<br></code></pre></td></tr></table></figure><p><strong>initialize_request() 源码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_request</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Returns the initial request object.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 解析上下文</span><br>        parser_context = self.get_parser_context(request)<br>  <br><span class="hljs-comment"># 构建了一个新的request</span><br>        <span class="hljs-keyword">return</span> Request(<br>            request,<br>            parsers=self.get_parsers(),<br>            authenticators=self.get_authenticators(),<br>            negotiator=self.get_content_negotiator(),<br>            parser_context=parser_context<br>        )<br></code></pre></td></tr></table></figure><p><strong>initial(): 源码</strong></p><p>步骤：</p><ul><li>获取格式化后缀</li><li>设置并执行内容协商</li><li>设置并进行   决策版本，确定版本</li><li>执行认证（重点）</li><li>检查权限</li><li>检查限流</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initial</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Runs anything that needs to occur prior to calling the method handler.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 获取格式化的后缀</span><br>        self.format_kwarg = self.get_format_suffix(**kwargs)<br><br>        <span class="hljs-comment"># Perform content negotiation and store the accepted info on the request</span><br>        <span class="hljs-comment"># 设置内容协商并存储请求中已接受的信息</span><br>        neg = self.perform_content_negotiation(request)<br>        <span class="hljs-comment"># 执行</span><br>        request.accepted_renderer, request.accepted_media_type = neg<br><br>        <span class="hljs-comment"># Determine the API version, if versioning is in use.</span><br>        <span class="hljs-comment"># 设置决策版本</span><br>        version, scheme = self.determine_version(request, *args, **kwargs)<br>        <span class="hljs-comment"># 执行确定版本</span><br>        request.version, request.versioning_scheme = version, scheme<br><br>        <span class="hljs-comment"># Ensure that the incoming request is permitted</span><br>        <span class="hljs-comment"># 执行认证，检查权限，检查限流</span><br>        self.perform_authentication(request)<br>        self.check_permissions(request)<br>        self.check_throttles(request)<br></code></pre></td></tr></table></figure><h5 id="3、GenericAPIView源码解析"><a href="#3、GenericAPIView源码解析" class="headerlink" title="3、GenericAPIView源码解析"></a>3、GenericAPIView源码解析</h5><p><code>GenericAPIView</code>继承自 <code>APIView</code>，也就是在 <code>APIView</code>基础上再做了一层封装</p><p><strong>类属性</strong></p><ol><li>queryset = None</li><li>serializer_class = None</li><li>lookup_field = ‘pk’</li><li>lookup_url_kwarg = None</li><li>filter_backends = api_settings.DEFAULT_FILTER_BACKENDS</li><li>pagination_class = api_settings.DEFAULT_PAGINATION_CLASS</li></ol><p><strong>queryset</strong><br>  queryset是用来控制视图返回给前端的数据。如果没什么逻辑，可以直接写在视图的类属性中，如果逻辑比较复杂，也可以重写get_queryset方法用来返回一个queryset对象。如果重写了get_queryset，那么以后获取queryset的时候就需要通过调用get_queryset方法。因为queryset` 这个属性只会调用一次，以后所有的请求都是使用他的缓存。</p><p><strong>serializer_class</strong><br>  serializer_class用来验证和序列化、反序列化数据的。也是可以通过直接设置这个属性，也可以通过重写get_serializer_class来实现。</p><p><strong>lookup_field</strong><br>在检索的时候，根据什么参数进行检索。默认是pk，也就是主键。</p><p><strong>lookup_url_kwarg</strong><br>在检索的url中的参数名称。默认没有设置，跟lookup_field保持一致。</p><p><strong>filter_backends</strong><br>用于过滤查询集的过滤器后端类的列表。默认值与DEFAULT_FILTER_BACKENDS 设置的值相同。</p><p><strong>pagination_class</strong><br>当分页列出结果时应使用的分页类。默认值与 DEFAULT_PAGINATION_CLASS 设置的值相同，即 ‘rest_framework.pagination.PageNumberPagination’。</p><p><strong>方法</strong></p><ol><li>get_queryset</li><li>get_object</li><li>get_serializer</li><li>get_serializer_class</li><li>get_serializer_context</li><li>filter_queryset</li></ol><p><strong>get_queryset</strong></p><p><code>get_queryset</code>默认是返回数据库全部数据，如果想返回其他数据，需要自定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_queryset</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 断言queryset是否不为None</span><br>    <span class="hljs-keyword">assert</span> self.queryset <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>, (<br>        <span class="hljs-string">&quot;&#x27;%s&#x27; should either include a `queryset` attribute, &quot;</span><br>        <span class="hljs-string">&quot;or override the `get_queryset()` method.&quot;</span><br>        % self.__class__.__name__<br>    )<br>  <br>    <span class="hljs-comment"># 定义queryset属性，获取父类的queryset，如果父类没有定义类属性`queryset`，那么默认值就是None，就会报上面断言的错误 </span><br>    queryset = self.queryset<br>    <span class="hljs-comment"># 如果queryset是QuerySet对象，那么返回全部内容</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(queryset, QuerySet):<br>        queryset = queryset.<span class="hljs-built_in">all</span>()<br>    <span class="hljs-comment"># 如果不是queryset，那么直接返回</span><br>    <span class="hljs-keyword">return</span> queryset<br></code></pre></td></tr></table></figure><p><strong>get_object</strong></p><p>该方法是用于在数据检索(通过pk查找)的时候，返回一条数据的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_object</span>(<span class="hljs-params">self</span>):<br>    queryset = self.filter_queryset(self.get_queryset())<br>  <br>    <span class="hljs-comment"># 查找过滤的条件，默认是pk</span><br>    lookup_url_kwarg = self.lookup_url_kwarg <span class="hljs-keyword">or</span> self.lookup_field<br> <br>    <span class="hljs-keyword">assert</span> lookup_url_kwarg <span class="hljs-keyword">in</span> self.kwargs, (<br>        <span class="hljs-string">&#x27;Expected view %s to be called with a URL keyword argument &#x27;</span><br>        <span class="hljs-string">&#x27;named &quot;%s&quot;. Fix your URL conf, or set the `.lookup_field` &#x27;</span><br>        <span class="hljs-string">&#x27;attribute on the view correctly.&#x27;</span> %<br>        (self.__class__.__name__, lookup_url_kwarg)<br>    )<br>  <br>    filter_kwargs = &#123;self.lookup_field: self.kwargs[lookup_url_kwarg]&#125;<br>    obj = get_object_or_404(queryset, **filter_kwargs)<br>  <br>    <span class="hljs-comment"># 可能会引发权限被拒绝</span><br>    self.check_object_permissions(self.request, obj)<br> <br>    <span class="hljs-keyword">return</span> obj<br></code></pre></td></tr></table></figure><p><strong>get_serializer</strong></p><p>返回应该用于验证和反序列化输入以及序列化输出的序列化器实例</p><p><strong>get_serializer_class</strong></p><p>返回用于序列化的类。默认使用 <code>self.serializer_class</code>。如果您需要根据传入请求提供不同的序列化，您可能需要重写它。</p><h3 id="3-2-5个视图扩展类"><a href="#3-2-5个视图扩展类" class="headerlink" title="3.2  5个视图扩展类"></a>3.2  5个视图扩展类</h3><p>作用：</p><p>提供了几种后端视图（对数据资源进行曾删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。</p><p>这五个扩展类需要搭配GenericAPIView父类，因为五个扩展类的实现需要调用GenericAPIView提供的序列化器与数据库查询的方法。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/ff12dc5e8ed14ea99c68f01278ddbe69.png" alt="image.png"></p><h4 id="1-ListModeMixin"><a href="#1-ListModeMixin" class="headerlink" title="(1) ListModeMixin"></a>(1) ListModeMixin</h4><p>列表视图扩展类，提供 <code>list(request, *args, **kwargs)</code>方法快速实现列表视图，返回200状态码。</p><p>该Mixin的list方法会对数据进行过滤和分页。</p><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class ListModelMixin(object):<br>    &quot;&quot;&quot;<br>    List a queryset.<br>    &quot;&quot;&quot;<br>    def list(self, request, *args, **kwargs):<br>        # 过滤<br>        queryset = self.filter_queryset(self.get_queryset())<br>        # 分页<br>        page = self.paginate_queryset(queryset)<br>        if page is not None:<br>            serializer = self.get_serializer(page, many=True)<br>            return self.get_paginated_response(serializer.data)<br>        # 序列化<br>        serializer = self.get_serializer(queryset, many=True)<br>        return Response(serializer.data)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.mixins import ListModelMixin<br><br>class BookListView(ListModelMixin, GenericAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br><br>    def get(self, request):<br>        return self.list(request)<br></code></pre></td></tr></table></figure><h4 id="2-CreateModeMixin"><a href="#2-CreateModeMixin" class="headerlink" title="(2) CreateModeMixin"></a>(2) CreateModeMixin</h4><p>创建视图扩展类，提供 <code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p><p>如果序列化器对前端发送的数据验证失败，返回400错误。</p><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class CreateModelMixin(object):<br>    &quot;&quot;&quot;<br>    Create a model instance.<br>    &quot;&quot;&quot;<br>    def create(self, request, *args, **kwargs):<br>        # 获取序列化器<br>        serializer = self.get_serializer(data=request.data)<br>        # 验证<br>        serializer.is_valid(raise_exception=True)<br>        # 保存<br>        self.perform_create(serializer)<br>        headers = self.get_success_headers(serializer.data)<br>        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)<br><br>    def perform_create(self, serializer):<br>        serializer.save()<br><br>    def get_success_headers(self, data):<br>        try:<br>            return &#123;&#x27;Location&#x27;: str(data[api_settings.URL_FIELD_NAME])&#125;<br>        except (TypeError, KeyError):<br>            return &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="3-RetrieveModelMixin"><a href="#3-RetrieveModelMixin" class="headerlink" title="(3) RetrieveModelMixin"></a>(3) RetrieveModelMixin</h4><p>详情视图扩展类，提供 <code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p><p>如果存在，返回200， 否则返回404。</p><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class RetrieveModelMixin(object):<br>    &quot;&quot;&quot;<br>    Retrieve a model instance.<br>    &quot;&quot;&quot;<br>    def retrieve(self, request, *args, **kwargs):<br>        # 获取对象，会检查对象的权限<br>        instance = self.get_object()<br>        # 序列化<br>        serializer = self.get_serializer(instance)<br>        return Response(serializer.data)<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookDetailView(RetrieveModelMixin, GenericAPIView):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br><br>    def get(self, request, pk):<br>        return self.retrieve(request)<br></code></pre></td></tr></table></figure><h4 id="4-UpdateModelMixin"><a href="#4-UpdateModelMixin" class="headerlink" title="(4) UpdateModelMixin"></a>(4) UpdateModelMixin</h4><p>更新视图扩展类，提供 <code>update(request, *args, **kwargs)</code>方法，可以快速实现更新一个存在的数据对象。</p><p>同时也提供 <code>partial_update(request, *args, **kwargs)</code>方法，可以实现局部更新。</p><p>成功返回200，序列化器校验数据失败时，返回400错误。</p><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class UpdateModelMixin(object):<br>    &quot;&quot;&quot;<br>    Update a model instance.<br>    &quot;&quot;&quot;<br>    def update(self, request, *args, **kwargs):<br>        partial = kwargs.pop(&#x27;partial&#x27;, False)<br>        instance = self.get_object()<br>        serializer = self.get_serializer(instance, data=request.data, partial=partial)<br>        serializer.is_valid(raise_exception=True)<br>        self.perform_update(serializer)<br><br>        if getattr(instance, &#x27;_prefetched_objects_cache&#x27;, None):<br>            # If &#x27;prefetch_related&#x27; has been applied to a queryset, we need to<br>            # forcibly invalidate the prefetch cache on the instance.<br>            instance._prefetched_objects_cache = &#123;&#125;<br><br>        return Response(serializer.data)<br><br>    def perform_update(self, serializer):<br>        serializer.save()<br><br>    def partial_update(self, request, *args, **kwargs):<br>        kwargs[&#x27;partial&#x27;] = True<br>        return self.update(request, *args, **kwargs)<br></code></pre></td></tr></table></figure><h4 id="5-DestroyModelMixin"><a href="#5-DestroyModelMixin" class="headerlink" title="(5) DestroyModelMixin"></a>(5) DestroyModelMixin</h4><p>删除视图扩展类，提供 <code>destroy(request, *args, **kwargs)</code>方法，可以快速实现删除一个存在的数据对象。</p><p>成功返回204，不存在返回404。</p><p>源代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class DestroyModelMixin(object):<br>    &quot;&quot;&quot;<br>    Destroy a model instance.<br>    &quot;&quot;&quot;<br>    def destroy(self, request, *args, **kwargs):<br>        instance = self.get_object()<br>        self.perform_destroy(instance)<br>        return Response(status=status.HTTP_204_NO_CONTENT)<br><br>    def perform_destroy(self, instance):<br>        instance.delete()<br></code></pre></td></tr></table></figure><h3 id="3-3-几个子类视图"><a href="#3-3-几个子类视图" class="headerlink" title="3.3 几个子类视图"></a>3.3 几个子类视图</h3><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/41ee2cb258b6458c9982f10787f98c3b.png" alt="image.png"></p><h4 id="1）CreateAPIView"><a href="#1）CreateAPIView" class="headerlink" title="(1）CreateAPIView"></a>(1）CreateAPIView</h4><p>提供 post 方法</p><p>继承自： GenericAPIView、CreateModelMixin</p><h4 id="2）ListAPIView"><a href="#2）ListAPIView" class="headerlink" title="(2）ListAPIView"></a>(2）ListAPIView</h4><p>提供 get 方法</p><p>继承自：GenericAPIView、ListModelMixin</p><h4 id="3）RetrieveAPIView"><a href="#3）RetrieveAPIView" class="headerlink" title="(3）RetrieveAPIView"></a>(3）RetrieveAPIView</h4><p>提供 get 方法</p><p>继承自: GenericAPIView、RetrieveModelMixin</p><h4 id="4）DestoryAPIView"><a href="#4）DestoryAPIView" class="headerlink" title="(4）DestoryAPIView"></a>(4）DestoryAPIView</h4><p>提供 delete 方法</p><p>继承自：GenericAPIView、DestoryModelMixin</p><h4 id="5）UpdateAPIView"><a href="#5）UpdateAPIView" class="headerlink" title="(5）UpdateAPIView"></a>(5）UpdateAPIView</h4><p>提供 put 和 patch 方法</p><p>继承自：GenericAPIView、UpdateModelMixin</p><h4 id="6）RetrieveUpdateAPIView"><a href="#6）RetrieveUpdateAPIView" class="headerlink" title="6）RetrieveUpdateAPIView"></a>6）RetrieveUpdateAPIView</h4><p>提供 get、put、patch方法</p><p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p><h4 id="7）RetrieveUpdateDestoryAPIView"><a href="#7）RetrieveUpdateDestoryAPIView" class="headerlink" title="7）RetrieveUpdateDestoryAPIView"></a>7）RetrieveUpdateDestoryAPIView</h4><p>提供 get、put、patch、delete方法</p><p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p><h3 id="3-4-视图集ViewSet"><a href="#3-4-视图集ViewSet" class="headerlink" title="3.4 视图集ViewSet"></a>3.4 视图集ViewSet</h3><p>为了让视图代码变得更加简短,让操作同一个模型的视图方法写在一个视图类中, drf提供了视图集[viewsets]。</p><ul><li><strong>1.视图集允许开发者自定义类视图方法名</strong></li><li><strong>2.视图集允许一个类分配多个不同的路由</strong></li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/a8176780480a4aefbcb0873a7eebc9c9.png" alt="image.png"></p><h4 id="3-4-1-常用视图集父类"><a href="#3-4-1-常用视图集父类" class="headerlink" title="3.4.1 常用视图集父类"></a>3.4.1 常用视图集父类</h4><p>(1) ViewSet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">继承自APIView与ViewSetMixin，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。<br><br>ViewSet主要通过继承ViewSetMixin来实现在调用as_view()时传入字典（如&#123;&#x27;get&#x27;:&#x27;list&#x27;&#125;）的映射处理工作。<br><br>在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。<br></code></pre></td></tr></table></figure><p>(2) GenericViewSet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">使用ViewSet通常并不方便，因为list、retrieve、create、update、destory等方法都需要自己编写，而这些方法与前面讲过的Mixin扩展类提供的方法同名，所以我们可以通过继承Mixin扩展类来复用这些方法而无需自己编写。但是Mixin扩展类依赖与GenericAPIView，所以还需要继承GenericAPIView。<br><br>GenericViewSet就帮助我们完成了这样的继承工作，继承自GenericAPIView与ViewSetMixin，在实现了调用as_view()时传入字典（如&#123;&#x27;get&#x27;:&#x27;list&#x27;&#125;）的映射处理工作的同时，还提供了GenericAPIView提供的基础方法，可以直接搭配Mixin扩展类使用。<br></code></pre></td></tr></table></figure><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework import mixins<br>from rest_framework.viewsets import GenericViewSet<br>from rest_framework.decorators import action<br><br>class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br></code></pre></td></tr></table></figure><p>url的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">urlpatterns = [<br>    url(r&#x27;^books/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;list&#x27;&#125;)),<br>    url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;retrieve&#x27;&#125;)),<br>]<br></code></pre></td></tr></table></figure><p>(3) ModelViewSet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">继承自GenericViewSet，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。<br></code></pre></td></tr></table></figure><p>(4) ReadOnlyModelViewSet</p><p>继承自 <code>GenericViewSet</code>，同时包括了ListModelMixin、RetrieveModelMixin。</p><h4 id="3-4-2-视图集中定义附加action动作"><a href="#3-4-2-视图集中定义附加action动作" class="headerlink" title="3.4.2 视图集中定义附加action动作"></a>3.4.2 视图集中定义附加action动作</h4><p>在视图集中，除了上述默认的方法动作外，还可以添加自定义动作。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework import mixins<br>from rest_framework.viewsets import GenericViewSet<br>from rest_framework.decorators import action<br><br>class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br><br>    def latest(self, request):<br>        &quot;&quot;&quot;<br>        返回最新的图书信息<br>        &quot;&quot;&quot;<br>        book = BookInfo.objects.latest(&#x27;id&#x27;)<br>        serializer = self.get_serializer(book)<br>        return Response(serializer.data)<br><br>    def read(self, request, pk):<br>        &quot;&quot;&quot;<br>        修改图书的阅读量数据<br>        &quot;&quot;&quot;<br>        book = self.get_object()<br>        book.bread = request.data.get(&#x27;read&#x27;)<br>        book.save()<br>        serializer = self.get_serializer(book)<br>        return Response(serializer.data)<br></code></pre></td></tr></table></figure><p>url的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">urlpatterns = [<br>    url(r&#x27;^books/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;list&#x27;&#125;)),<br>    url(r&#x27;^books/latest/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;latest&#x27;&#125;)),<br>    url(r&#x27;^books/(?P&lt;pk&gt;\d+)/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;get&#x27;: &#x27;retrieve&#x27;&#125;)),<br>    url(r&#x27;^books/(?P&lt;pk&gt;\d+)/read/$&#x27;, views.BookInfoViewSet.as_view(&#123;&#x27;put&#x27;: &#x27;read&#x27;&#125;)),<br>]<br></code></pre></td></tr></table></figure><h4 id="3-4-3-action属性"><a href="#3-4-3-action属性" class="headerlink" title="3.4.3 action属性"></a>3.4.3 action属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework.viewsets import ModelViewSet,ReadOnlyModelViewSet<br>from booktest.models import BookInfo<br>from .serializers import BookInfoModelSerializer<br>from rest_framework.response import Response<br>class BookInfoModelViewSet(ModelViewSet):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoModelSerializer<br><br>    def get_top_5(self,request):<br>        &quot;&quot;&quot;获取评论值最多的5条数据&quot;&quot;&quot;<br>        # 操作数据库<br>        print(self.action) # 获取本次请求的视图方法名<br></code></pre></td></tr></table></figure><p>通过路由访问到当前方法中，可以看到本次的action就是请求的方法名</p><h3 id="3-5-路由Routers"><a href="#3-5-路由Routers" class="headerlink" title="3.5 路由Routers"></a>3.5 路由Routers</h3><p>对于视图集ViewSet，我们除了可以自己手动指明请求方式与动作action之间的对应关系外，还可以使用Routers来帮助我们快速实现路由信息。</p><p>REST framework提供了两个router</p><ul><li><strong>SimpleRouter</strong></li><li><strong>DefaultRouter</strong></li></ul><h4 id="3-5-1-使用方法"><a href="#3-5-1-使用方法" class="headerlink" title="3.5.1 使用方法"></a>3.5.1 使用方法</h4><p>(1) 创建router对象，并注册视图集，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework import routers<br><br>router = routers.SimpleRouter()<br>router.register(r&#x27;books&#x27;, BookInfoViewSet, base_name=&#x27;book&#x27;)<br></code></pre></td></tr></table></figure><p>register(prefix, viewset, base_name)</p><ul><li>prefix 该视图集的路由前缀</li><li>viewset 视图集</li><li>base_name 路由名称的前缀</li></ul><p>如上述代码会形成的路由如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">^books/$    name: book-list<br>^books/&#123;pk&#125;/$   name: book-detail<br></code></pre></td></tr></table></figure><p>(2) 添加路由数据</p><p>可以有两种方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">urlpatterns = [<br>    ...<br>]<br>urlpatterns += router.urls<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">urlpatterns = [<br>    ...<br>    url(r&#x27;^&#x27;, include(router.urls))<br>]<br></code></pre></td></tr></table></figure><h4 id="3-5-2-视图集中附加action的声明"><a href="#3-5-2-视图集中附加action的声明" class="headerlink" title="3.5.2 视图集中附加action的声明"></a>3.5.2 视图集中附加action的声明</h4><p>在视图集中，如果想要让Router自动帮助我们为自定义的动作生成路由信息，需要使用 <code>rest_framework.decorators.action</code>装饰器。</p><p>以action装饰器装饰的方法名会作为action动作名，与list、retrieve等同。</p><p>action装饰器可以接收两个参数：</p><ul><li><strong>methods</strong> : 声明该action对应的请求方式，列表传递</li><li><p>detail声明该action的路径是否与单一资源对应，及是否是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">xxx/&lt;pk&gt;/action方法名/<br></code></pre></td></tr></table></figure></li><li>True表示路径格式是：xxx/<pk>/action方法名/</li><li>False表示路径格式是：xxx/action方法名</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework import mixins<br>from rest_framework.viewsets import GenericViewSet<br>from rest_framework.decorators import action<br><br>class BookInfoViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet):<br>    queryset = BookInfo.objects.all()<br>    serializer_class = BookInfoSerializer<br><br>    # detail为False 表示路径名格式应该为 books/latest/<br>    @action(methods=[&#x27;get&#x27;], detail=False)<br>    def latest(self, request):<br>        &quot;&quot;&quot;<br>        返回最新的图书信息<br>        &quot;&quot;&quot;<br>        ...<br><br>    # detail为True，表示路径名格式应该为 books/&#123;pk&#125;/read/<br>    @action(methods=[&#x27;put&#x27;], detail=True)<br>    def read(self, request, pk):<br>        &quot;&quot;&quot;<br>        修改图书的阅读量数据<br>        &quot;&quot;&quot;<br>        ...<br></code></pre></td></tr></table></figure><p>由路由器自动为此视图集自定义action方法形成的路由会是如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">^books/latest/$    name: book-latest<br>^books/&#123;pk&#125;/read/$  name: book-read<br></code></pre></td></tr></table></figure><h4 id="3-5-3-路由router形成URL的方法"><a href="#3-5-3-路由router形成URL的方法" class="headerlink" title="3.5.3 路由router形成URL的方法"></a>3.5.3 路由router形成URL的方法</h4><p>1） SimpleRouter</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16194/1671445017088/a16bf5dca5084794a9734c49c3c1de45.png" alt="image.png"></p><p>2）DefaultRouter</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/16194/1671445017088/c4af57783b814f24b9f5c455111a05b1.png" alt="image.png"></p><p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。</p><h2 id="4-JWT"><a href="#4-JWT" class="headerlink" title="4 JWT"></a>4 JWT</h2><p>JWT<br>JSON Web Token（JSON Web令牌）</p><p>是一个开放标准(rfc7519)，它定义了一种紧凑的、自包含的方式，用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密〈使用HNAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。</p><p>通过JSON形式作为Web应用中的令牌，用于在各方之间安全地将信息作为JSON对象传输。在数据传输过程中还可以完成数据加密、签名等相关处理。</p><p>JWT作用：<br>授权：一旦用户登录，每个后续请求将包括JWT，从而允许用户访问该令牌允许的路由，服务和资源。它的开销很小并且可以在不同的域中使用。如：单点登录。<br>信息交换：在各方之间安全地传输信息。JWT可进行签名（如使用公钥/私钥对)，因此可确保发件人。由于签名是使用标头和有效负载计算的，因此还可验证内容是否被篡改。<br><img src="https:///img-blog.csdn/img.cn/20201029154848467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvcF9MMzk4,size_16,color_FFFFFF,t_70#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(/img-4Njwu2Yt-1603957559915)(E:/LiuPengLearn/LiuP%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%B7%AF/Java%E6%8A%80%E6%9C%AF%E6%95%B4%E5%90%88/JWT/images/image-20200917201624900.png)]"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/482/1620998133146189824/98a020d466004863ac8da862b296cbae.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">1) jwt = base64(头部).base(载荷).hash256(base64(头部).base(载荷).密钥)<br>2) base64是可逆的算法、hash256是不可逆的算法<br>3) 密钥是固定的字符串，保存在服务器<br></code></pre></td></tr></table></figure><h3 id="4-1-DRF-JWT"><a href="#4-1-DRF-JWT" class="headerlink" title="4.1 DRF-JWT"></a>4.1 DRF-JWT</h3><p>官网：<a href="http://getblimp.github.io/django-rest-framework-jwt/">http://getblimp.github.io/django-rest-framework-jwt/</a></p><h4 id="4-1-1-安装"><a href="#4-1-1-安装" class="headerlink" title="4.1.1 安装"></a>4.1.1 安装</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">pip install djangorestframework-jwt<br></code></pre></td></tr></table></figure><h4 id="4-1-2-使用"><a href="#4-1-2-使用" class="headerlink" title="4.1.2 使用"></a>4.1.2 使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from django.urls import path<br>from rest_framework_jwt.views import obtain_jwt_token<br>urlpatterns = [<br>    path(&#x27;login/&#x27;, obtain_jwt_token),<br>]<br></code></pre></td></tr></table></figure><h4 id="4-1-3-测试"><a href="#4-1-3-测试" class="headerlink" title="4.1.3 测试"></a>4.1.3 测试</h4><p>(案例需要提前准备）</p><h4 id="4-1-4-DRF-JWT开发"><a href="#4-1-4-DRF-JWT开发" class="headerlink" title="4.1.4 DRF-JWT开发"></a>4.1.4 DRF-JWT开发</h4><p>配置信息：JWT_auth到dev.py中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import datetime<br>JWT_AUTH = &#123;<br>    # 过期时间<br>    &#x27;JWT_EXPIRATION_DELTA&#x27;: datetime.timedelta(days=1),<br>    # 自定义认证结果：见下方序列化user和自定义response<br>    &#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;: &#x27;user.utils.jwt_response_payload_handler&#x27;,  <br>&#125;<br></code></pre></td></tr></table></figure><p>序列化user：user/serializers.py(自己创建)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework import serializers<br>from . import models<br>class UserModelSerializers(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.User<br>        fields = [&#x27;username&#x27;]<br></code></pre></td></tr></table></figure><p>自定义response：user/utils.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from .serializers import UserModelSerializers<br>def jwt_response_payload_handler(token, user=None, request=None):<br>    return &#123;<br>        &#x27;status&#x27;: 0,<br>        &#x27;msg&#x27;: &#x27;ok&#x27;,<br>        &#x27;data&#x27;: &#123;<br>            &#x27;token&#x27;: token,<br>            &#x27;user&#x27;: UserModelSerializers(user).data<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>基于drf-jwt的全局认证：user/authentications.py（自己创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import jwt<br>from rest_framework.exceptions import AuthenticationFailed<br>from rest_framework_jwt.authentication import jwt_decode_handler<br>from rest_framework_jwt.authentication import get_authorization_header<br>from rest_framework_jwt.authentication import BaseJSONWebTokenAuthentication<br><br>class JSONWebTokenAuthentication(BaseJSONWebTokenAuthentication):<br>    def authenticate(self, request):<br>        jwt_value = get_authorization_header(request)<br><br>        if not jwt_value:<br>            raise AuthenticationFailed(&#x27;Authorization 字段是必须的&#x27;)<br>        try:<br>            payload = jwt_decode_handler(jwt_value)<br>        except jwt.ExpiredSignature:<br>            raise AuthenticationFailed(&#x27;签名过期&#x27;)<br>        except jwt.InvalidTokenError:<br>            raise AuthenticationFailed(&#x27;非法用户&#x27;)<br>        user = self.authenticate_credentials(payload)<br><br>        return user, jwt_value<br></code></pre></td></tr></table></figure><p>全局启用：settings/dev.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">REST_FRAMEWORK = &#123;<br>    # 认证模块<br>    &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: (<br>        &#x27;user.authentications.JSONWebTokenAuthentication&#x27;,<br># DRF自带的JWT认证模块<br>#&#x27;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#x27;,<br>    ),<br>&#125;<br><br></code></pre></td></tr></table></figure><p>局部启用禁用：任何一个cvb类首行设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 局部禁用<br>authentication_classes = []<br><br># 局部启用<br>from user.authentications import JSONWebTokenAuthentication<br>authentication_classes = [JSONWebTokenAuthentication]<br></code></pre></td></tr></table></figure><p>自定义代码登录：user/utils.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">import re<br>from .models import User<br>from django.contrib.auth.backends import ModelBackend<br>class JWTModelBackend(ModelBackend):<br>    def authenticate(self, request, username=None, password=None, **kwargs):<br>        try:<br>            if re.match(r&#x27;^1[3-9]\d&#123;9&#125;$&#x27;, username):<br>                user = User.objects.get(mobile=username)<br>            else:<br>                user = User.objects.get(username=username)<br>        except User.DoesNotExist:<br>            return None<br>        if user.check_password(password) and self.user_can_authenticate(user):<br>            return user<br></code></pre></td></tr></table></figure><p>配置自定义登录：settings/dev.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">AUTHENTICATION_BACKENDS = [&#x27;user.utils.JWTModelBackend&#x27;]<br></code></pre></td></tr></table></figure><p>手动签发JWT：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from rest_framework_jwt.settings import api_settings<br><br>jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER<br>jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER<br><br>payload = jwt_payload_handler(user)<br>token = jwt_encode_handler(payload)<br></code></pre></td></tr></table></figure><h2 id="5-Django-DRF序列化器-Serializer"><a href="#5-Django-DRF序列化器-Serializer" class="headerlink" title="5 Django DRF序列化器 Serializer"></a>5 Django DRF序列化器 Serializer</h2><h3 id="5-1-定义序列化器"><a href="#5-1-定义序列化器" class="headerlink" title="5.1 定义序列化器"></a>5.1 定义序列化器</h3><p>Django REST framework中的Serializer使用类来定义，须继承自rest_framework.serializers.Serializer。</p><p>例如，我们已有了一个数据库模型类BookInfo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfo(models.Model):<br>    btitle = models.CharField(max_length=20, verbose_name=&#x27;名称&#x27;)<br>    bpub_date = models.DateField(verbose_name=&#x27;发布日期&#x27;, null=True)<br>    bread = models.IntegerField(default=0, verbose_name=&#x27;阅读量&#x27;)<br>    bcomment = models.IntegerField(default=0, verbose_name=&#x27;评论量&#x27;)<br>    image = models.ImageField(upload_to=&#x27;booktest&#x27;, verbose_name=&#x27;图片&#x27;, null=True)<br></code></pre></td></tr></table></figure><p>我们想为这个模型类提供一个序列化器，可以定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    id = serializers.IntegerField(label=&#x27;ID&#x27;, read_only=True)<br>    btitle = serializers.CharField(label=&#x27;名称&#x27;, max_length=20)<br>    bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;, required=False)<br>    bread = serializers.IntegerField(label=&#x27;阅读量&#x27;, required=False)<br>    bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;, required=False)<br>    image = serializers.ImageField(label=&#x27;图片&#x27;, required=False)<br></code></pre></td></tr></table></figure><p><strong>注意：serializer不是只能为数据库模型类定义，也可以为非数据库模型类的数据定义。</strong> serializer是独立于数据库之外的存在。</p><h4 id="常用字段类型"><a href="#常用字段类型" class="headerlink" title="常用字段类型"></a>常用字段类型</h4><p><strong>常用字段类型</strong> ：</p><div class="table-container"><table><thead><tr><th>字段</th><th>字段构造方式</th></tr></thead><tbody><tr><td><strong>BooleanField</strong></td><td>BooleanField()</td></tr><tr><td><strong>NullBooleanField</strong></td><td>NullBooleanField()</td></tr><tr><td><strong>CharField</strong></td><td>CharField(max_length=None, min_length=None, allow_blank=False, trim_whitespace=True)</td></tr><tr><td><strong>EmailField</strong></td><td>EmailField(max_length=None, min_length=None, allow_blank=False)</td></tr><tr><td><strong>RegexField</strong></td><td>RegexField(regex, max_length=None, min_length=None, allow_blank=False)</td></tr><tr><td><strong>SlugField</strong></td><td>SlugField(max_length=50, min_length=None, allow_blank=False) 正则字段，验证正则模式 [a-zA-Z0-9*-]+</td></tr><tr><td><strong>URLField</strong></td><td>URLField(max_length=200, min_length=None, allow_blank=False)</td></tr><tr><td><strong>UUIDField</strong></td><td>UUIDField(format=’hex_verbose’) format: 1)<code>&#39;hex_verbose&#39;</code> 如 <code>&quot;5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code> 2） <code>&#39;hex&#39;</code> 如 <code>&quot;5ce0e9a55ffa654bcee01238041fb31a&quot;</code> 3）<code>&#39;int&#39;</code> - 如: <code>&quot;123456789012312313134124512351145145114&quot;</code> 4）<code>&#39;urn&#39;</code> 如: <code>&quot;urn:uuid:5ce0e9a5-5ffa-654b-cee0-1238041fb31a&quot;</code></td></tr><tr><td><strong>IPAddressField</strong></td><td>IPAddressField(protocol=’both’, unpack_ipv4=False, **options)</td></tr><tr><td><strong>IntegerField</strong></td><td>IntegerField(max_value=None, min_value=None)</td></tr><tr><td><strong>FloatField</strong></td><td>FloatField(max_value=None, min_value=None)</td></tr><tr><td><strong>DecimalField</strong></td><td>DecimalField(max_digits, decimal_places, coerce_to_string=None, max_value=None, min_value=None) max_digits: 最多位数 decimal_palces: 小数点位置</td></tr><tr><td><strong>DateTimeField</strong></td><td>DateTimeField(format=api_settings.DATETIME_FORMAT, input_formats=None)</td></tr><tr><td><strong>DateField</strong></td><td>DateField(format=api_settings.DATE_FORMAT, input_formats=None)</td></tr><tr><td><strong>TimeField</strong></td><td>TimeField(format=api_settings.TIME_FORMAT, input_formats=None)</td></tr><tr><td><strong>DurationField</strong></td><td>DurationField()</td></tr><tr><td><strong>ChoiceField</strong></td><td>ChoiceField(choices) choices与Django的用法相同</td></tr><tr><td><strong>MultipleChoiceField</strong></td><td>MultipleChoiceField(choices)</td></tr><tr><td><strong>FileField</strong></td><td>FileField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td></tr><tr><td><strong>ImageField</strong></td><td>ImageField(max_length=None, allow_empty_file=False, use_url=UPLOADED_FILES_USE_URL)</td></tr><tr><td><strong>ListField</strong></td><td>ListField(child=, min_length=None, max_length=None)</td></tr><tr><td><strong>DictField</strong></td><td>DictField(child=)</td></tr></tbody></table></div><h4 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h4><p><strong>选项参数：</strong></p><div class="table-container"><table><thead><tr><th>参数名称</th><th>作用</th></tr></thead><tbody><tr><td><strong>max_length</strong></td><td>最大长度</td></tr><tr><td><strong>min_lenght</strong></td><td>最小长度</td></tr><tr><td><strong>allow_blank</strong></td><td>是否允许为空</td></tr><tr><td><strong>trim_whitespace</strong></td><td>是否截断空白字符</td></tr><tr><td><strong>max_value</strong></td><td>最小值</td></tr><tr><td><strong>min_value</strong></td><td>最大值</td></tr></tbody></table></div><h4 id="通用参数"><a href="#通用参数" class="headerlink" title="通用参数"></a>通用参数</h4><div class="table-container"><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>read_only</strong></td><td>表明该字段仅用于序列化输出，默认False</td></tr><tr><td><strong>write_only</strong></td><td>表明该字段仅用于反序列化输入，默认False</td></tr><tr><td><strong>required</strong></td><td>表明该字段在反序列化时必须输入，默认True</td></tr><tr><td><strong>default</strong></td><td>反序列化时使用的默认值</td></tr><tr><td><strong>allow_null</strong></td><td>表明该字段是否允许传入None，默认False</td></tr><tr><td><strong>validators</strong></td><td>该字段使用的验证器</td></tr><tr><td><strong>error_messages</strong></td><td>包含错误编号与错误信息的字典</td></tr><tr><td><strong>label</strong></td><td>用于HTML展示API页面时，显示的字段名称</td></tr><tr><td><strong>help_text</strong></td><td>用于HTML展示API页面时，显示的字段帮助提示信息</td></tr></tbody></table></div><h3 id="5-2-创建Serializer对象"><a href="#5-2-创建Serializer对象" class="headerlink" title="5.2 创建Serializer对象"></a>5.2 创建Serializer对象</h3><p>序列化器有四大功能：</p><ul><li>反序列化 ： 把请求（request）中参数(字典) ——-&gt; （模型）对象</li><li>请求参数校验 ：</li><li>保存和修改模型对象（数据库）：save</li><li>序列化： 把（模型）对象 ———&gt; 字典（——-&gt;json由response来完成）</li></ul><p>定义好Serializer类后，就可以创建Serializer对象了。</p><p>Serializer的构造方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Serializer(instance=None, data=empty, **kwarg)<br></code></pre></td></tr></table></figure><p>说明：</p><p>1）用于序列化时，将模型类对象传入<strong>instance</strong>参数</p><p>2）用于反序列化时，将要被反序列化的数据传入<strong>data</strong>参数</p><p>3）除了instance和data参数外，在构造Serializer对象时，还可通过<strong>context</strong>参数额外添加数据，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">serializer = AccountSerializer(account, context=&#123;&#x27;request&#x27;: request&#125;)<br></code></pre></td></tr></table></figure><p><strong>通过context参数附加的数据，可以通过Serializer对象的context属性获取。</strong></p><ol><li>使用序列化器的时候一定要注意，序列化器声明了以后，不会自动执行，需要我们在视图中进行调用才可以。</li><li>序列化器无法直接接收数据，需要我们在视图中创建序列化器对象时把使用的数据传递过来。</li><li>序列化器的字段声明类似于我们前面使用过的表单系统。</li><li>开发restful api时，序列化器会帮我们把模型数据转换成字典.</li><li>drf提供的视图会帮我们把字典转换成json,或者把客户端发送过来的数据转换字典.</li></ol><p>序列化器的使用分两个阶段：</p><ol><li>在客户端请求时，使用序列化器可以完成对数据的反序列化。</li><li>在服务器响应时，使用序列化器可以完成对数据的序列化。</li></ol><h3 id="5-3-序列化"><a href="#5-3-序列化" class="headerlink" title="5.3 序列化"></a>5.3 序列化</h3><h4 id="5-3-1-基本使用"><a href="#5-3-1-基本使用" class="headerlink" title="5.3.1 基本使用"></a>5.3.1 基本使用</h4><p>(1) 先查询出一个图书对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from booktest.models import BookInfo<br><br>book = BookInfo.objects.get(id=2)<br></code></pre></td></tr></table></figure><p>(2) 构造序列化对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer<br><br>serializer = BookInfoSerializer(book)<br></code></pre></td></tr></table></figure><p>(3) 获取序列化数据</p><p>通过data属性可以获取序列化后的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">serializer.data<br># &#123;&#x27;id&#x27;: 2, &#x27;btitle&#x27;: &#x27;天龙八部&#x27;, &#x27;bpub_date&#x27;: &#x27;1986-07-24&#x27;, &#x27;bread&#x27;: 36, &#x27;bcomment&#x27;: 40, &#x27;image&#x27;: None&#125;<br></code></pre></td></tr></table></figure><p>(4) 如果要被序列化的是包含多条数据的查询集QuerySet，可以通过添加many=True参数补充说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">book_qs = BookInfo.objects.all()<br>serializer = BookInfoSerializer(book_qs, many=True)<br>serializer.data<br># [OrderedDict([(&#x27;id&#x27;, 2), (&#x27;btitle&#x27;, &#x27;天龙八部&#x27;), (&#x27;bpub_date&#x27;, &#x27;1986-07-24&#x27;), (&#x27;bread&#x27;, 36), (&#x27;bcomment&#x27;, 40), (&#x27;image&#x27;, N]), OrderedDict([(&#x27;id&#x27;, 3), (&#x27;btitle&#x27;, &#x27;笑傲江湖&#x27;), (&#x27;bpub_date&#x27;, &#x27;1995-12-24&#x27;), (&#x27;bread&#x27;, 20), (&#x27;bcomment&#x27;, 80), (&#x27;image&#x27;ne)]), OrderedDict([(&#x27;id&#x27;, 4), (&#x27;btitle&#x27;, &#x27;雪山飞狐&#x27;), (&#x27;bpub_date&#x27;, &#x27;1987-11-11&#x27;), (&#x27;bread&#x27;, 58), (&#x27;bcomment&#x27;, 24), (&#x27;ima None)]), OrderedDict([(&#x27;id&#x27;, 5), (&#x27;btitle&#x27;, &#x27;西游记&#x27;), (&#x27;bpub_date&#x27;, &#x27;1988-01-01&#x27;), (&#x27;bread&#x27;, 10), (&#x27;bcomment&#x27;, 10), (&#x27;im&#x27;, &#x27;booktest/xiyouji.png&#x27;)])]<br></code></pre></td></tr></table></figure><h3 id="5-4-反序列化"><a href="#5-4-反序列化" class="headerlink" title="5.4 反序列化"></a>5.4 反序列化</h3><p>进行反序列化之前，必须先进行数据验证</p><p>使用序列化器进行反序列化时，需要对数据进行验证后，才能获取验证成功的数据或保存成模型类对象。</p><p>在获取反序列化的数据前，必须调用 <strong>is_valid()</strong> 方法进行验证，验证成功返回True，否则返回False。</p><p>验证失败，可以通过序列化器对象的<strong>errors</strong>属性获取错误信息，返回字典，包含了字段和字段的错误。如果是非字段错误，可以通过修改REST framework配置中的<strong>NON_FIELD_ERRORS_KEY</strong>来控制错误字典中的键名。</p><p>验证成功，可以通过序列化器对象的<strong>validated_data</strong>属性获取数据。</p><p>在定义序列化器时，指明每个字段的序列化类型和选项参数，本身就是一种验证行为。</p><p>如我们前面定义过的BookInfoSerializer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    id = serializers.IntegerField(label=&#x27;ID&#x27;, read_only=True)<br>    btitle = serializers.CharField(label=&#x27;名称&#x27;, max_length=20)<br>    bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;, required=False)<br>    bread = serializers.IntegerField(label=&#x27;阅读量&#x27;, required=False)<br>    bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;, required=False)<br>    image = serializers.ImageField(label=&#x27;图片&#x27;, required=False)<br></code></pre></td></tr></table></figure><p>通过构造序列化器对象，并将要反序列化的数据传递给data构造参数，进而进行验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer<br>data = &#123;&#x27;bpub_date&#x27;: 123&#125;<br>serializer = BookInfoSerializer(data=data)<br>serializer.is_valid()  # 返回False<br>serializer.errors<br># &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;This field is required.&#x27;, code=&#x27;required&#x27;)], &#x27;bpub_date&#x27;: [ErrorDetail(string=&#x27;Date has wrong format. Use one of these formats instead: YYYY[-MM[-DD]].&#x27;, code=&#x27;invalid&#x27;)]&#125;<br>serializer.validated_data  # &#123;&#125;<br><br>data = &#123;&#x27;btitle&#x27;: &#x27;python&#x27;&#125;<br>serializer = BookInfoSerializer(data=data)<br>serializer.is_valid()  # True<br>serializer.errors  # &#123;&#125;<br>serializer.validated_data  #  OrderedDict([(&#x27;btitle&#x27;, &#x27;python&#x27;)])<br></code></pre></td></tr></table></figure><p>is_valid()方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递<strong>raise_exception=True</strong>参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># Return a 400 response if the data was invalid.<br>serializer.is_valid(raise_exception=True)<br></code></pre></td></tr></table></figure><p>(1) validate_字段名</p><p>对<field_name>字典进行验证，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    ...<br><br>    def validate_btitle(self, value):<br>        if &#x27;django&#x27; not in value.lower():<br>            raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)<br>        return value<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer<br>data = &#123;&#x27;btitle&#x27;: &#x27;python&#x27;&#125;<br>serializer = BookInfoSerializer(data=data)<br>serializer.is_valid()  # False   <br>serializer.errors<br>#  &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;图书不是关于Django的&#x27;, code=&#x27;invalid&#x27;)]&#125;<br></code></pre></td></tr></table></figure><p>(2) validate</p><p>在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer<br>data = &#123;&#x27;btitle&#x27;: &#x27;about django&#x27;, &#x27;bread&#x27;: 10, &#x27;bcomment&#x27;: 20&#125;<br>s = BookInfoSerializer(data=data)<br>s.is_valid()  # False<br>s.errors<br>#  &#123;&#x27;non_field_errors&#x27;: [ErrorDetail(string=&#x27;阅读量小于评论量&#x27;, code=&#x27;invalid&#x27;)]&#125;<br></code></pre></td></tr></table></figure><p>(3) validators</p><p>在字段中添加validators选项参数，也可以补充验证行为，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">def about_django(value):<br>    if &#x27;django&#x27; not in value.lower():<br>        raise serializers.ValidationError(&quot;图书不是关于Django的&quot;)<br><br>class BookInfoSerializer(serializers.Serializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    id = serializers.IntegerField(label=&#x27;ID&#x27;, read_only=True)<br>    btitle = serializers.CharField(label=&#x27;名称&#x27;, max_length=20, validators=[about_django])<br>    bpub_date = serializers.DateField(label=&#x27;发布日期&#x27;, required=False)<br>    bread = serializers.IntegerField(label=&#x27;阅读量&#x27;, required=False)<br>    bcomment = serializers.IntegerField(label=&#x27;评论量&#x27;, required=False)<br>    image = serializers.ImageField(label=&#x27;图片&#x27;, required=False)<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from booktest.serializers import BookInfoSerializer<br>data = &#123;&#x27;btitle&#x27;: &#x27;python&#x27;&#125;<br>serializer = BookInfoSerializer(data=data)<br>serializer.is_valid()  # False   <br>serializer.errors<br>#  &#123;&#x27;btitle&#x27;: [ErrorDetail(string=&#x27;图书不是关于Django的&#x27;, code=&#x27;invalid&#x27;)]&#125;<br></code></pre></td></tr></table></figure><h3 id="反序列化-保存数据"><a href="#反序列化-保存数据" class="headerlink" title="反序列化-保存数据"></a>反序列化-保存数据</h3><p>前面的验证数据成功后,我们可以使用序列化器来完成数据反序列化的过程.这个过程可以把数据转成模型类对象.</p><p>可以通过实现create()和update()两个方法来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.Serializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    ...<br><br>    def create(self, validated_data):<br>        &quot;&quot;&quot;新建&quot;&quot;&quot;<br>        return BookInfo(**validated_data)<br><br>    def update(self, instance, validated_data):<br>        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;<br>        instance.btitle = validated_data.get(&#x27;btitle&#x27;, instance.btitle)<br>        instance.bpub_date = validated_data.get(&#x27;bpub_date&#x27;, instance.bpub_date)<br>        instance.bread = validated_data.get(&#x27;bread&#x27;, instance.bread)<br>        instance.bcomment = validated_data.get(&#x27;bcomment&#x27;, instance.bcomment)<br>        return instance<br></code></pre></td></tr></table></figure><p>如果需要在返回数据对象的时候，也将数据保存到数据库中，则可以进行如下修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>class BookInfoSerializer(serializers.Serializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    ...<br><br>    def create(self, validated_data):<br>        &quot;&quot;&quot;新建&quot;&quot;&quot;<br>        return BookInfo.objects.create(**validated_data)<br><br>    def update(self, instance, validated_data):<br>        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;<br>        instance.btitle = validated_data.get(&#x27;btitle&#x27;, instance.btitle)<br>        instance.bpub_date = validated_data.get(&#x27;bpub_date&#x27;, instance.bpub_date)<br>        instance.bread = validated_data.get(&#x27;bread&#x27;, instance.bread)<br>        instance.bcomment = validated_data.get(&#x27;bcomment&#x27;, instance.bcomment)<br>        instance.save()<br>        return instance<br></code></pre></td></tr></table></figure><p>实现了上述两个方法后，在反序列化数据的时候，就可以通过save()方法返回一个数据对象实例了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">book = serializer.save()<br></code></pre></td></tr></table></figure><p>如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用，相反，如果传递了instance实例，则调用save()方法的时候，update()被调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">from db.serializers import BookInfoSerializer<br>data = &#123;&#x27;btitle&#x27;: &#x27;封神演义&#x27;&#125;<br>serializer = BookInfoSerializer(data=data)<br>serializer.is_valid()  # True<br>serializer.save()  # &lt;BookInfo: 封神演义&gt;<br><br>from db.models import BookInfo<br>book = BookInfo.objects.get(id=2)<br>data = &#123;&#x27;btitle&#x27;: &#x27;倚天剑&#x27;&#125;<br>serializer = BookInfoSerializer(book, data=data)<br>serializer.is_valid()  # True<br>serializer.save()  # &lt;BookInfo: 倚天剑&gt;<br>book.btitle  # &#x27;倚天剑&#x27;<br></code></pre></td></tr></table></figure><p>说明：</p><p>（1）在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># request.user 是django中记录当前登录用户的模型对象<br>serializer.save(owner=request.user)<br></code></pre></td></tr></table></figure><p>（2）默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># Update `comment` with partial data<br>serializer = CommentSerializer(comment, data=&#123;&#x27;content&#x27;: u&#x27;foo bar&#x27;&#125;, partial=True)<br></code></pre></td></tr></table></figure><h3 id="模型类序列化器"><a href="#模型类序列化器" class="headerlink" title="模型类序列化器"></a>模型类序列化器</h3><p>如果我们想要使用序列化器对应的是Django的模型类，DRF为我们提供了ModelSerializer模型类序列化器来帮助我们快速创建一个Serializer类。</p><p>ModelSerializer与常规的Serializer相同，但提供了：</p><ul><li>基于模型类自动生成一系列字段</li><li>基于模型类自动为Serializer生成validators，比如unique_together</li><li>包含默认的create()和update()的实现</li></ul><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>比如我们创建一个BookInfoSerializer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    class Meta:<br>        model = BookInfo<br>        fields = &#x27;__all__&#x27;<br></code></pre></td></tr></table></figure><ul><li>model 指明参照哪个模型类</li><li>fields 指明为模型类的哪些字段生成</li></ul><p>我们可以在python manage.py shell中查看自动生成的BookInfoSerializer的具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&gt;&gt;&gt; from booktest.serializers import BookInfoSerializer<br>&gt;&gt;&gt; serializer = BookInfoSerializer()<br>&gt;&gt;&gt; serializer<br>BookInfoSerializer():<br>    id = IntegerField(label=&#x27;ID&#x27;, read_only=True)<br>    btitle = CharField(label=&#x27;名称&#x27;, max_length=20)<br>    bpub_date = DateField(allow_null=True, label=&#x27;发布日期&#x27;, required=False)<br>    bread = IntegerField(label=&#x27;阅读量&#x27;, max_value=2147483647, min_value=-2147483648, required=False)<br>    bcomment = IntegerField(label=&#x27;评论量&#x27;, max_value=2147483647, min_value=-2147483648, required=False)<br>    image = ImageField(allow_null=True, label=&#x27;图片&#x27;, max_length=100, required=False)<br></code></pre></td></tr></table></figure><h4 id="指定字段"><a href="#指定字段" class="headerlink" title="指定字段"></a>指定字段</h4><p>使用<strong>fields</strong>来明确字段，<code>__all__</code>表名包含所有字段，也可以写明具体哪些字段，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    class Meta:<br>        model = BookInfo<br>        fields = (&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;)<br></code></pre></td></tr></table></figure><p>使用exclude可以明确排序掉哪些字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    class Meta:<br>        model = BookInfo<br>        exclude = (&#x27;image&#x27;,)<br></code></pre></td></tr></table></figure><p>显示指明字段，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class HeroInfoSerializer(serializers.ModelSerializer):<br>    hbook = BookInfoSerializer()<br><br>    class Meta:<br>        model = HeroInfo<br>        fields = (&#x27;id&#x27;, &#x27;hname&#x27;, &#x27;hgender&#x27;, &#x27;hcomment&#x27;, &#x27;hbook&#x27;)<br></code></pre></td></tr></table></figure><p>指明只读字段</p><p>可以通过read_only_fields指明只读字段，既仅用于序列化输出的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    class Meta:<br>        model = BookInfo<br>        fields = (&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;， &#x27;bread&#x27;, &#x27;bcomment&#x27;)<br>        read_only_fields = (&#x27;id&#x27;, &#x27;bread&#x27;, &#x27;bcomment&#x27;)<br></code></pre></td></tr></table></figure><h4 id="添加额外参数"><a href="#添加额外参数" class="headerlink" title="添加额外参数"></a>添加额外参数</h4><p>我们可以使用extra_kwargs参数为ModelSerializer添加或修改原有的选项参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class BookInfoSerializer(serializers.ModelSerializer):<br>    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;<br>    class Meta:<br>        model = BookInfo<br>        fields = (&#x27;id&#x27;, &#x27;btitle&#x27;, &#x27;bpub_date&#x27;, &#x27;bread&#x27;, &#x27;bcomment&#x27;)<br>        extra_kwargs = &#123;<br>            &#x27;bread&#x27;: &#123;&#x27;min_value&#x27;: 0, &#x27;required&#x27;: True&#125;,<br>            &#x27;bcomment&#x27;: &#123;&#x27;min_value&#x27;: 0, &#x27;required&#x27;: True&#125;,<br>        &#125;<br><br># BookInfoSerializer():<br>#    id = IntegerField(label=&#x27;ID&#x27;, read_only=True)<br>#    btitle = CharField(label=&#x27;名称&#x27;, max_length=20)<br>#    bpub_date = DateField(allow_null=True, label=&#x27;发布日期&#x27;, required=False)<br>#    bread = IntegerField(label=&#x27;阅读量&#x27;, max_value=2147483647, min_value=0, required=True)<br>#    bcomment = IntegerField(label=&#x27;评论量&#x27;, max_value=2147483647, min_value=0, required=True)<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;DRF框架&quot;&gt;&lt;a href=&quot;#DRF框架&quot; class=&quot;headerlink&quot; title=&quot;DRF框架&quot;&gt;&lt;/a&gt;DRF框架&lt;/h4&gt;&lt;h2 id=&quot;1-DRF入门&quot;&gt;&lt;a href=&quot;#1-DRF入门&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="test" scheme="http://localhost:4000/categories/test/"/>
    
    
    <category term="test" scheme="http://localhost:4000/tags/test/"/>
    
  </entry>
  
</feed>
